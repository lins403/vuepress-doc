(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{517:function(t,a,l){"use strict";l.r(a);var p=l(43),e=Object(p.a)({},(function(){var t=this,a=t.$createElement,l=t._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"call-与-apply"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#call-与-apply"}},[t._v("#")]),t._v(" call 与 apply")]),t._v(" "),l("h4",{attrs:{id:"安全地apply函数"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#安全地apply函数"}},[t._v("#")]),t._v(" 安全地apply函数")]),t._v(" "),l("p",[t._v("在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性(虽然可能性极小)。 为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如:"),l("code",[t._v("Function.prototype.apply.call(myFunc, thisVal, argumentList);")])]),t._v(" "),l("p",[t._v("这种可怕的代码完全可以使用 Reflect.apply 来避免: "),l("code",[t._v("Reflect.apply(myFunc, thisVal, argumentsList);")])]),t._v(" "),l("h3",{attrs:{id:"reflect-apply"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#reflect-apply"}},[t._v("#")]),t._v(" Reflect.apply")])])}),[],!1,null,null,null);a.default=e.exports}}]);