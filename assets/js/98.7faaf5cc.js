(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{498:function(v,_,l){"use strict";l.r(_);var t=l(43),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"线性表的实现"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线性表的实现"}},[v._v("#")]),v._v(" 线性表的实现")]),v._v(" "),l("h2",{attrs:{id:"顺序存储"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#顺序存储"}},[v._v("#")]),v._v(" 顺序存储")]),v._v(" "),l("ul",[l("li",[v._v("顺序存储需要连续的存储空间")]),v._v(" "),l("li",[v._v("静态存储分配、动态存储分配")]),v._v(" "),l("li",[v._v("随机访问，通过首地址和元素序号可在时间O(1)内找到指定的元素")])]),v._v(" "),l("h2",{attrs:{id:"链式存储"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#链式存储"}},[v._v("#")]),v._v(" 链式存储")]),v._v(" "),l("ul",[l("li",[v._v("单链表")]),v._v(" "),l("li",[v._v("双链表\n"),l("ul",[l("li",[v._v("单链表要访问某个结点的前趋结点只能从头开始顺序地向后遍历")]),v._v(" "),l("li",[v._v("在单链表的基础上增加一个指向其前趋的prior指针")])])]),v._v(" "),l("li",[v._v("循环链表")]),v._v(" "),l("li",[v._v("静态链表\n"),l("ul",[l("li",[v._v("借助数组来描述线性表，这里的指针是结点的相对地址（数组下标），又称游标")]),v._v(" "),l("li",[v._v("和顺序表一样要预先分配一块连续的存储空间")]),v._v(" "),l("li",[v._v("用在一些不支持指针的高级语言（如Basic）中")])])])]),v._v(" "),l("h2",{attrs:{id:"顺序表和链表的比较"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#顺序表和链表的比较"}},[v._v("#")]),v._v(" 顺序表和链表的比较")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("存储（读写）方式")]),v._v(" "),l("ul",[l("li",[v._v("顺序表可以顺序存取，也可以随机存取")]),v._v(" "),l("li",[v._v("链表只能从表头顺序存取元素")])])]),v._v(" "),l("li",[l("p",[v._v("逻辑结构与物理结构")]),v._v(" "),l("ul",[l("li",[v._v("采用顺序存取时，逻辑相邻的元素，对应的物理存储位置也相邻")]),v._v(" "),l("li",[v._v("采用链式存取时，对应的逻辑关系是通过指针链接来表示的")])])]),v._v(" "),l("li",[l("p",[v._v("查找、插入和删除操作")]),v._v(" "),l("ul",[l("li",[v._v("按值查找")]),v._v(" "),l("li",[v._v("按序号查找")]),v._v(" "),l("li",[v._v("链表的插入删除操作，只需修改相关结点的指针域即可。由于每个结点都带有指针域，故而存储密度不够大")])])]),v._v(" "),l("li",[l("p",[v._v("空间分配")])])])])}),[],!1,null,null,null);_.default=i.exports}}]);