(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{438:function(t,a,s){"use strict";s.r(a);var r=s(43),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加密"}},[t._v("#")]),t._v(" 加密")]),t._v(" "),s("ul",[s("li",[t._v("AES")]),t._v(" "),s("li",[t._v("RSA")]),t._v(" "),s("li",[t._v("MD5")]),t._v(" "),s("li",[t._v("BASE64")]),t._v(" "),s("li",[t._v("SM4")])]),t._v(" "),s("p",[t._v("BASE64 编码，常用来做转码，把二进制字节序列转化为 ASCII 字符序列。")]),t._v(" "),s("h2",{attrs:{id:"概念词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念词"}},[t._v("#")]),t._v(" 概念词")]),t._v(" "),s("h3",{attrs:{id:"_1-陷门函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-陷门函数"}},[t._v("#")]),t._v(" 1）陷门函数")]),t._v(" "),s("p",[t._v("Trapdoor Function，Trap door - 暗门，类似于地窖口的门，只能向外一侧打开")]),t._v(" "),s("p",[t._v("一种容易计算函数值而不容易求逆的函数，即解密比加密难")]),t._v(" "),s("h3",{attrs:{id:"_2-pkcs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-pkcs"}},[t._v("#")]),t._v(" 2）PKCS")]),t._v(" "),s("p",[t._v("公钥加密标准（Public Key Cryptography Standards, PKCS），此一标准的设计与发布皆由 RSA信息安全公司（RSA Security）所制定。")]),t._v(" "),s("p",[s("code",[t._v("PKCS1")]),t._v("(Public-Key Cryptography Standards #1)，定义了RSA 密钥必需的数学特性、公/私钥格式，以及加/解密、签/验章的流程")]),t._v(" "),s("h2",{attrs:{id:"生成随机数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成随机数"}},[t._v("#")]),t._v(" 生成随机数")]),t._v(" "),s("p",[t._v("算法加密很大程度上基于随机数生成算法")]),t._v(" "),s("h3",{attrs:{id:"math-random"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#math-random"}},[t._v("#")]),t._v(" Math.random()")]),t._v(" "),s("p",[s("code",[t._v("Math.random()")]),t._v(" 在浏览器中是以伪随机数生成器 ("),s("strong",[t._v("PRNG")]),t._v("，PseudoRandom Number Generator)方式实现的。所谓“伪”指的是生成值的过程不是真的随机。PRNG 生成的值只是模拟了随机的特性。浏览器的 PRNG 并未使用真正的随机源，只是对一个内部状态应用了固定的算法。每次调用 Math.random()，这个内部状态都会被一个算法修改，而结果会被转换为一个新的随机值。例如，V8 引擎使用了一个名为 xorshift128+ 的算法来执行这种修改。")]),t._v(" "),s("p",[t._v("由于算法本身是固定的，其输入只是之前的状态，因此随机数顺序也是确定的。xorshift128+使用 128 位内部状态，而算法的设计让任何初始状态在重复自身之前都会产生 2^128–1 个伪随机值。这种循环 被称为置换循环(permutation cycle)，而这个循环的长度被称为一个周期(period)。很明显，如果攻击者知道 PRNG 的内部状态，就可以预测后续生成的伪随机值。如果开发者无意中使用 PRNG 生成了私有 密钥用于加密，则攻击者就可以利用 PRNG 的这个特性算出私有密钥。")]),t._v(" "),s("p",[t._v("所以伪随机数生成器主要用于快速计算出看起来随机的值，而并不适合用于加密计算。")]),t._v(" "),s("h3",{attrs:{id:"crypto-getrandomvalues"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#crypto-getrandomvalues"}},[t._v("#")]),t._v(" crypto.getRandomValues()")]),t._v(" "),s("p",[t._v("为解决这个问题，密码学安全伪随机数生成器("),s("strong",[t._v("CSPRNG")]),t._v("，Cryptographically Secure PseudoRandom Number Generator) 额外增加了一个熵作为输入，例如测试硬件时间或其他无法预计行为的系统特性。这样一来，计算速度明显比常规 PRNG 慢很多，但 CSPRNG 生成的值就很难预测，可以用于加密了。")]),t._v(" "),s("p",[t._v("Web Cryptography API 引入了 CSPRNG，这个 CSPRNG 可以通过 crypto.getRandomValues() 在全局 Crypto 对象上访问。")]),t._v(" "),s("p",[s("code",[t._v("crypto.getRandomValues()")]),t._v(" 会把随机值写入作为参数传给它的定型数组")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** 使用 crypto.getRandomValues() 模拟 Math.random() **/")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("randomFloat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 生成 32 位随机值")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fooArray "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Uint32Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最大值是2^32 –1")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" maxUint32 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFFFFFFFF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用最大可能的值来除")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" crypto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRandomValues")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fooArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" maxUint32"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("randomFloat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 0.8903489459516362")]),t._v("\n")])])]),s("h2",{attrs:{id:"密码学摘要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#密码学摘要"}},[t._v("#")]),t._v(" 密码学摘要")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("SHA-1")]),t._v("(Secure Hash Algorithm 1): 架构类似 MD5 的散列函数。接收任意大小的输入，生成 160 位消息散列。由于容易受到碰撞攻击，这个算法已经不再安全。")]),t._v(" "),s("li",[s("code",[t._v("SHA-2")]),t._v("(Secure Hash Algorithm 2): 构建于相同耐碰撞单向压缩函数之上的一套散列函数。规范支持其中 3 种: SHA-256、SHA-384 和 SHA-512。生成的消息摘要可以是 256 位(SHA-256)、 384 位(SHA-384)或 512 位(SHA-512)。"),s("u",[t._v("这个算法被认为是安全的，广泛应用于很多领域和协议，包括 TLS、PGP 和加密货币(如比特币)。")])])]),t._v(" "),s("h2",{attrs:{id:"加密算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加密算法"}},[t._v("#")]),t._v(" 加密算法")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("全称")]),t._v(" "),s("th",[t._v("描述")]),t._v(" "),s("th",[t._v("陷门函数")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("RSA")]),t._v(" "),s("td",[t._v("Rivest-Shamir-Adleman")]),t._v(" "),s("td",[t._v("公钥密码系统，使用两个大素数获得一对公钥和私钥，可用于签名/验证或加密/解密消息。")]),t._v(" "),s("td",[t._v("分解难题(factoring problem)")])]),t._v(" "),s("tr",[s("td",[t._v("ECC")]),t._v(" "),s("td",[t._v("Elliptic-Curve Cryptography")]),t._v(" "),s("td",[t._v("公钥密码系统，使用一个素数和一个椭圆曲线获得一对公钥和私钥，可用于签名/验证消息。")]),t._v(" "),s("td",[t._v("椭圆曲线离散对数问题"),s("br"),t._v("(elliptic curve discrete logarithm problem)")])]),t._v(" "),s("tr",[s("td",[t._v("HMAC")]),t._v(" "),s("td",[t._v("Hash-Based Message Authentication Code")]),t._v(" "),s("td",[t._v("使用密码散列函数，同时结合一个加密密钥来计算，所产生的消息认证码。"),s("br"),t._v("可以用来保证资料的完整性，同时可以用来作某个消息的身份验证。")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("AES")]),t._v(" "),s("td",[t._v("Advanced Encryption Standard")]),t._v(" "),s("td",[t._v("对称密钥密码系统")]),t._v(" "),s("td",[t._v("-")])])])]),t._v(" "),s("h1",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[t._v("《JavaScript高级程序设计（第4版）》20.12 Web Cryptography API")])])}),[],!1,null,null,null);a.default=n.exports}}]);