(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{409:function(e,t,a){"use strict";a.r(t);var r=a(43),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[e._v("#")]),e._v(" 浏览器")]),e._v(" "),a("h2",{attrs:{id:"渲染原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染原理"}},[e._v("#")]),e._v(" 渲染原理")]),e._v(" "),a("p",[e._v("The pixel pipeline:  JavaScript > Style calculations > Layout > Paint > Composite")]),e._v(" "),a("p",[a("strong",[e._v("JavaScript")]),e._v("：使用 JavaScript 来实现一些视觉变化的效果")]),e._v(" "),a("p",[a("strong",[e._v("样式计算")]),e._v("：匹配selectors，应用css规则，计算每个元素的最终样式")]),e._v(" "),a("p",[a("strong",[e._v("布局")]),e._v("：计算它要占据的空间大小及其在屏幕的位置")]),e._v(" "),a("p",[a("strong",[e._v("绘制")]),e._v("：创建绘图调用的列表（a list of draw calls），填充像素（也叫“栅格化” (rasterize) ），绘制多个图层")]),e._v(" "),a("p",[a("strong",[e._v("合成")]),e._v("：合成多个图层")]),e._v(" "),a("p",[e._v("为了确保平滑滚动和动画，占据**"),a("u",[e._v("主线程")]),a("strong",[e._v("的所有内容，包括计算样式，以及reflow和paint，必须让浏览器在")]),a("u",[e._v("60帧（16.67毫秒）")]),e._v("**内完成。为了确保重绘repaint的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。")]),e._v(" "),a("p",[e._v("绘制可以将Layout tree中的元素分解为多个层。将内容提升到GPU上的层，可以提高绘制和重绘的性能。")]),e._v(" "),a("p",[e._v("渲染进程：主线程、合成线程、栅格线程")]),e._v(" "),a("h2",{attrs:{id:"重排和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重排和重绘"}},[e._v("#")]),e._v(" 重排和重绘")]),e._v(" "),a("h3",{attrs:{id:"重排reflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重排reflow"}},[e._v("#")]),e._v(" 重排reflow")]),e._v(" "),a("blockquote",[a("p",[a("em",[e._v("Reflow")]),e._v(" is any subsequent size and position determination of any part of the page or the entire document.")]),e._v(" "),a("p",[e._v("The first time the size and position of nodes are determined is called "),a("em",[e._v("layout")]),e._v(". Subsequent recalculations of node size and locations are called "),a("em",[e._v("reflows")]),e._v(".")])]),e._v(" "),a("p",[e._v("修改了元素的layout属性，影响到其它元素的布局，例如  width, height, position 等等")]),e._v(" "),a("p",[e._v("Recalculate Style--\x3eLayout--\x3eUpdate Layer Tree--\x3e以及之后各个流程")]),e._v(" "),a("h3",{attrs:{id:"重绘repaint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘repaint"}},[e._v("#")]),e._v(" 重绘repaint")]),e._v(" "),a("p",[e._v("修改了元素的“paint only”属性，不会影响到页面布局，例如 background, text color, shadows 等等，浏览器的渲染会掉过布局，直接进行绘制")]),e._v(" "),a("p",[e._v("Recalculate Style--\x3eUpdate Layer Tree--\x3e以及之后各个流程")]),e._v(" "),a("h3",{attrs:{id:"特殊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特殊"}},[e._v("#")]),e._v(" 特殊")]),e._v(" "),a("ul",[a("li",[e._v("动画、滚动")]),e._v(" "),a("li",[a("u",[e._v("opacity、transform")]),e._v("（通过transform实现的动画不需要进行样式计算、布局和绘制等操作）")])]),e._v(" "),a("p",[e._v("既不要布局也不要绘制，浏览器会跳过布局和绘制，直接执行合成")]),e._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("重排和重绘都是占用浏览器主线程，主线程JavaScript的执行可能就会给页面的重排和重绘造成影响，造成下一帧的画面不能按时渲染， 例如导致动画卡顿")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("我觉得有不少歧义，按MDN的解释加之我的理解，浏览器会解析css构建CSSOM，然后和DOM树一起合并（combined）生成render tree，随后执行layout布局，去遍历render tree，确定树中每个node的size和position，按照每个元素的盒模型（box model properties，就是content、padding、border、margin等）排列，这样子才得到了Layout tree。")]),e._v(" "),a("p",[e._v("paint阶段就是将Layout tree上的每个box转换成页面上的实际像素。")]),e._v(" "),a("p",[e._v("而为了保证能在60帧内完成渲染，需要确保重绘的性能比原始绘制时高，paint阶段会将layout tree的元素取出分成多个图层，不同图层相互重叠的时候就要合成（composite），按照绘制顺序合成多个图层，然后展示到屏幕上。")]),e._v(" "),a("p",[e._v("把图层分块（tile），对每个块单独栅格化，填充像素到位图上，生成一帧，然后上传GPU。按MDN说的，图层当是将内容提升到GPU上的层。")]),e._v(" "),a("p",[a("code",[e._v("<canvas>")]),e._v(" 和 "),a("code",[e._v("<video>")]),e._v("，以及使用 "),a("code",[e._v("opacity")]),e._v(" 和 "),a("code",[e._v("transform")]),e._v(" 这些css属性的元素，可以实例化一个图层（instantiate a layer），这些元素和它们的后代节点，都会在这个图层上独立进行绘制，从而避开了主线程中的layout与paint环节。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work",target:"_blank",rel:"noopener noreferrer"}},[e._v("Populating the page: how browsers work"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("requestAnimationFrame我看到别的博客提到节流效果，用节流解释太妙了。")])])}),[],!1,null,null,null);t.default=o.exports}}]);