(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{450:function(t,a,r){"use strict";r.r(a);var v=r(43),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[t._v("#")]),t._v(" 术语")]),t._v(" "),r("h2",{attrs:{id:"一、工程化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、工程化"}},[t._v("#")]),t._v(" 一、工程化")]),t._v(" "),r("h3",{attrs:{id:"基准测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基准测试"}},[t._v("#")]),t._v(" 基准测试")]),t._v(" "),r("p",[t._v("当更新同一应用程序（包括软件、硬件、网络和代码更改）时，它将再次通过性能测试，并且新的性能指标结果与以前的性能指标结果进行比较。")]),t._v(" "),r("h3",{attrs:{id:"可维护性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可维护性"}},[t._v("#")]),t._v(" 可维护性")]),t._v(" "),r("p",[t._v("容易理解、符合常识、容易适配、容易扩展、容易调试")]),t._v(" "),r("ol",[r("li",[t._v("编程规范")]),t._v(" "),r("li",[t._v("松散耦合")]),t._v(" "),r("li",[t._v("编码惯例")])]),t._v(" "),r("h2",{attrs:{id:"二、功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、功能"}},[t._v("#")]),t._v(" 二、功能")]),t._v(" "),r("h3",{attrs:{id:"盗链"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#盗链"}},[t._v("#")]),t._v(" 盗链")]),t._v(" "),r("p",[t._v("盗链是指在自己的页面上展示一些并不在自己服务器上的内容")]),t._v(" "),r("h3",{attrs:{id:"repl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#repl"}},[t._v("#")]),t._v(" REPL")]),t._v(" "),r("p",[t._v("read-eval-print-loop，读取 - 求值 - 打印 - 循环")]),t._v(" "),r("p",[t._v("浏览器控制台是个REPL运行时，与页面的 JavaScript 运行时并发。在控制台中执行的命令可以像页面级 JavaScript 一样访问全局和各种 API。控制台中可以执行任意数量的代码，与它可能会阻塞的任何页面级代码一样。修改、对象和回调都会保留在 DOM 和运行时中。")]),t._v(" "),r("h2",{attrs:{id:"三、编程设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、编程设计模式"}},[t._v("#")]),t._v(" 三、编程设计模式")]),t._v(" "),r("h3",{attrs:{id:"控制反转模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#控制反转模式"}},[t._v("#")]),t._v(" 控制反转模式")]),t._v(" "),r("p",[r("strong",[t._v("控制反转")]),t._v("（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。")]),t._v(" "),r("p",[t._v("实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("依赖注入（Dependency Injection，DI）是"),r("strong",[t._v("被动")]),t._v("的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中。")])]),t._v(" "),r("li",[r("p",[t._v("依赖查找（Dependency Lookup）是"),r("strong",[t._v("主动")]),t._v("索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。")])])]),t._v(" "),r("p",[t._v("IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。对于某个具体的对象而言，以前是由它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。")]),t._v(" "),r("p",[t._v("IoC的一个重点是，在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过依赖注入来实现的，而spring中具体注入方式是通过反射（reflection）来实现的。")]),t._v(" "),r("blockquote",[r("p",[t._v("控制反转IoC是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC 容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);