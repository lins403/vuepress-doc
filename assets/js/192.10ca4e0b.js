(window.webpackJsonp=window.webpackJsonp||[]).push([[192],{591:function(t,e,n){"use strict";n.r(e);var a=n(43),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据驱动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据驱动"}},[t._v("#")]),t._v(" 数据驱动")]),t._v(" "),n("p",[t._v("数据驱动视图。不用直接修改DOM，只需要修改数据，就可以修改视图。")]),t._v(" "),n("h2",{attrs:{id:"大致过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#大致过程"}},[t._v("#")]),t._v(" 大致过程")]),t._v(" "),n("ol",[n("li",[t._v("new Vue 实例化")]),t._v(" "),n("li",[t._v("init 初始化")]),t._v(" "),n("li",[t._v("$mount 实例挂载 【compileTofunctions、mountComponent  >>>  "),n("code",[t._v("vm._update(vm._render())")]),t._v(" 】")]),t._v(" "),n("li",[t._v("compile 编译 template 生成 render functions【compile（parse、generate）】")]),t._v(" "),n("li",[t._v("render 生成 vnode【createElement、createComponent、new VNode】")]),t._v(" "),n("li",[t._v("update 中调用 "),n("code",[t._v("vm.__patch__")]),t._v(" 更新实例节点 vm.$el")]),t._v(" "),n("li",[t._v("patch 中对新旧 vnode 进行 Diff，动态更新【patchVnode、updateChildren、createElm】")]),t._v(" "),n("li",[t._v("createElm 中调用 DOM API 来创建真实DOM")]),t._v(" "),n("li",[t._v("最终的DOM")])]),t._v(" "),n("p",[n("strong",[t._v("new Vue => init => $mount => compile => render => vnode => patch => DOM")])]),t._v(" "),n("h2",{attrs:{id:"new-vue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-vue"}},[t._v("#")]),t._v(" new Vue")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("mergeOptions\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//========================================")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initProxy")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 利用ES6的Proxy特性，为vm实例设置一层代理，这层代理可以为vue在模板渲染成VNode时进行一层数据筛选 （vnode = render.call(vm._renderProxy, vm.$createElement) 在render阶段对不合法的数据做判断和处理 ）")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initLifecycle")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initEvents")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initRender")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//初始化slot、vm._c、vm.$createElement、vm._vnode、vm.$vnode")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//========================================")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("callHook")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'beforeCreate'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//========================================")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initInjections")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// props、methods、data、computed、watch")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("initProvide")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//========================================")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("callHook")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'created'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//========================================")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$options"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("el"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("$mount")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$options"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("el"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 挂载的目标就是把模板渲染成最终的DOM")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h2",{attrs:{id:"mergeoptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mergeoptions"}},[t._v("#")]),t._v(" mergeOptions")]),t._v(" "),n("p",[n("code",[t._v("mergeOptions")]),t._v(" 主要功能就是把 "),n("code",[t._v("parent")]),t._v(" 和 "),n("code",[t._v("child")]),t._v(" 这两个对象根据一些合并策略，合并成一个新对象并返回。")]),t._v(" "),n("p",[t._v("比较核心的几步，先递归把 "),n("code",[t._v("extends")]),t._v(" 和 "),n("code",[t._v("mixins")]),t._v(" 合并到 "),n("code",[t._v("parent")]),t._v(" 上，然后遍历 "),n("code",[t._v("parent")]),t._v("，调用 "),n("code",[t._v("mergeField")]),t._v("，然后再遍历 "),n("code",[t._v("child")]),t._v("，如果 "),n("code",[t._v("key")]),t._v(" 不在 "),n("code",[t._v("parent")]),t._v(" 的自身属性上，则调用 "),n("code",[t._v("mergeField")]),t._v("。")]),t._v(" "),n("p",[n("code",[t._v("mergeField")]),t._v(" 函数，它对不同的 "),n("code",[t._v("key")]),t._v(" 有着不同的合并策略。")]),t._v(" "),n("ul",[n("li",[t._v("data/props/computed/methods/provide/inject，相同 key 的时候 child (instance options) 的值会覆盖 parent (extends、mixins) 的值")]),t._v(" "),n("li",[t._v("components/directives/filters，会进行三方合并（constructor、instance、parent）")]),t._v(" "),n("li",[t._v("watch/ lifecycle hooks，以数组的方式合并，依次执行，parent优先")])]),t._v(" "),n("h2",{attrs:{id:"挂载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#挂载"}},[t._v("#")]),t._v(" 挂载")]),t._v(" "),n("p",[t._v("挂载的目的就是把模板渲染成最终的真实DOM")]),t._v(" "),n("h3",{attrs:{id:"compiler-版本的-mount-实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compiler-版本的-mount-实现"}},[t._v("#")]),t._v(" "),n("code",[t._v("compiler")]),t._v(" 版本的 "),n("code",[t._v("$mount")]),t._v(" 实现")]),t._v(" "),n("p",[t._v("没有定义 "),n("code",[t._v("render function")]),t._v("（hand-written render functions / JSX），则无论是 el 还是 template，最后都会被调用 compileToFunctions 编译成 render function")]),t._v(" "),n("h3",{attrs:{id:"runtime-版本的-mount-实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runtime-版本的-mount-实现"}},[t._v("#")]),t._v(" "),n("code",[t._v("runtime")]),t._v(" 版本的 "),n("code",[t._v("$mount")]),t._v(" 实现")]),t._v(" "),n("p",[t._v("实际会去调用 "),n("code",[t._v("mountComponent")]),t._v(" 方法")]),t._v(" "),n("p",[n("code",[t._v("mountComponent")]),t._v(" 核心就是先实例化一个"),n("code",[t._v("render Watcher")]),t._v("，在它的回调函数中会调用 "),n("code",[t._v("updateComponent")]),t._v(" 方法，在此方法中调用 "),n("code",[t._v("vm._render")]),t._v(" 方法先生成 "),n("code",[t._v("VNode")]),t._v("，最终调用 "),n("code",[t._v("vm._update")]),t._v(" 更新 DOM。")]),t._v(" "),n("p",[t._v("创建一个Watcher实例，Watcher的getter为updateComponent (--\x3evm._update)函数，用于触发所有渲染所需要用到的数据的getter，进行依赖收集")]),t._v(" "),n("h3",{attrs:{id:"vm-render"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vm-render"}},[t._v("#")]),t._v(" "),n("code",[t._v("vm._render")])]),t._v(" "),n("p",[t._v("用来把实例渲染成一个虚拟 Node")]),t._v(" "),n("p",[t._v("如果没有定义 "),n("code",[t._v("render function")]),t._v("，那么在这之前需要将 template 模板编译为 render function，然后调用"),n("code",[t._v("vm._render")]),t._v(" 方法，执行 "),n("code",[t._v("createElement")]),t._v(" 方法，最终生成 VNode")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("vnode "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_renderProxy"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$createElement"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("h4",{attrs:{id:"createelement"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[t._v("#")]),t._v(" createElement")]),t._v(" "),n("ol",[n("li",[t._v("normalizeChildren，每一个 VNode 可能会有若干个子节点，首先需要对这些子节点进行规范化，例如处理函数式组件，或者编译slot、v-for时产生嵌套数组的情况。(组件的vnode没有children，普通元素节点的vnode才会有)")]),t._v(" "),n("li",[t._v("规范化 "),n("code",[t._v("children")]),t._v(" 后，接下来会去创建一个 VNode 的实例")])]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 根据 tag 的类型 */")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// platform built-in elements")]),t._v("\nvnode "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VNode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  config"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("parsePlatformTagName")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("tag"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" data"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" children"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" context\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// component")]),t._v("\nvnode "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("createComponent")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Ctor"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" data"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" context"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" children"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tag"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n")])])]),n("h4",{attrs:{id:"virtual-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[t._v("#")]),t._v(" Virtual DOM")]),t._v(" "),n("blockquote",[n("p",[t._v("每个组件或节点都会被编译成render function，然后调用render函数渲染生成VNode，整个页面的组件树就会变成由一个个 VNode 组成的 VNode 树，把它称为 Virtual DOM。所以 vdom 和 vnode 都在用一个原生对象去描述 DOM 树，一种抽象描述，包含了创建 DOM 所需要的信息。")])]),t._v(" "),n("p",[t._v("真正的 DOM 节点非常庞大和复杂，频繁的更新 DOM 会造成很大的性能消耗。")]),t._v(" "),n("p",[t._v("Virtual DOM 比创建一个 DOM 的代价要小很多。")]),t._v(" "),n("p",[t._v("Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。")]),t._v(" "),n("p",[n("strong",[t._v("虚拟DOM和真实的DOM的差异")]),t._v("：")]),t._v(" "),n("ol",[n("li",[t._v("资源消耗更低")]),t._v(" "),n("li",[t._v("执行效率更高。Diff算法比较，策略更新，减少了操作真实DOM的次数")]),t._v(" "),n("li",[t._v("可以跨平台。编译成其它平台的系统，例如android、ios")])]),t._v(" "),n("h3",{attrs:{id:"vm-update"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vm-update"}},[t._v("#")]),t._v(" "),n("code",[t._v("vm._update")])]),t._v(" "),n("p",[t._v("作用是把 VNode 渲染成真实的 DOM。")]),t._v(" "),n("p",[n("code",[t._v("_update")]),t._v(" 的核心就是调用 "),n("code",[t._v("vm.__patch__")]),t._v(" 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// initial render")]),t._v("\nvm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$el "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("__patch__")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$el"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hydrating"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* removeOnly */")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// patch函数")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("patch")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldVnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hydrating"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*SSR*/")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" removeOnly"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*给transition-group用的*/")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h4",{attrs:{id:"vm-patch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vm-patch"}},[t._v("#")]),t._v(" "),n("code",[t._v("vm.__patch__")])]),t._v(" "),n("ul",[n("li",[t._v("patch 的过程会调用 "),n("code",[t._v("createElm")]),t._v(" 创建元素节点。createElm 通过 VNode 创建真实的 DOM 并插入到它的父节点中，createChildren会递归调用createElm")]),t._v(" "),n("li",[t._v("组件更新时也会调用 "),n("code",[t._v("vm._update")]),t._v(" 方法，调用 "),n("code",[t._v("patch")]),t._v(" 函数，判断新旧VNode的节点是否相同，如果不同则直接替换已存在的节点，如果相同则调用 "),n("code",[t._v("patchVNode")]),t._v(" 进行Diff比较，按策略更新节点。")])]),t._v(" "),n("p",[t._v("更新DOM")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** Vue.prototype._update **/")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("prevVnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// initial render")]),t._v("\n      vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$el "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("__patch__")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$el"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hydrating"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* removeOnly */")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$options"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_parentElm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$options"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_refElm\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// updates")]),t._v("\n      vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$el "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("__patch__")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevVnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vnode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("钩子")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// hooks to be invoked on component VNodes during patch\nconst componentVNodeHooks = {\n\tinit (--\x3ecreateComponentInstanceForVnode、child.$mount)\n\tprepatch (--\x3eupdateChildComponent)\n\tinsert (--\x3ecallHook(componentInstance, 'mounted'))\n\tdestroy (--\x3e$destroy())\n")])])]),n("h2",{attrs:{id:"问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),n("h3",{attrs:{id:"数据驱动-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据驱动-2"}},[t._v("#")]),t._v(" 数据驱动")]),t._v(" "),n("p",[t._v("一个vue项目的入口是从实例化new Vue开始的。实例化Vue时，首先进行mergeOptions合并选项，合并来自组件自身的也就是实例options，和使用extends或者mixins拓展的options。")]),t._v(" "),n("ul",[n("li",[t._v("mergeOptions合并策略：不同的选项基于不同的合并策略，像是data/props/computed/methods这些呢，如果属性名一样，那么实例options对应的属性值就会覆盖掉拓展的。如果是watch侦听属性或者是lifecycle生命周期，就会以数组的方式进行合并，如果key相同则二者都会被保留，执行的时候拓展的options会先执行，然后再执行实例options的。还有一种情况是components和directives这些选项，还会和全局Vue中对应的选项，进行一个三方合并。这是实例化Vue首先进行的mergeOptions。")])]),t._v(" "),n("p",[t._v("然后下一步就去初始化化生命周期钩子、事件、render等等，为后续做铺垫。")]),t._v(" "),n("p",[t._v("紧接着调用生命周期的beforeCreate钩子，然后就开始实例化数据了。首先在初始化状态前先initInjections，然后初始化state，包含props、methods、data、computed、watch等等，然后再initProvide。")]),t._v(" "),n("ul",[n("li",[t._v("初始化状态最主要做了两件事情，一个是将props、computed以及methods经过标准化以后，绑定到实例上，就能作为实例属性直接访问，第二个是对它们以及data中的属性进行数据劫持，也就是把它们变成响应式对象。完成这个阶段的初始化以后，就会触发生命周期的created钩子，这时候代码就能访问到数据了。")])]),t._v(" "),n("p",[t._v("完成初始化状态以后，判断如果实例的option中有el节点属性，就会将实例去挂载到这个DOM节点上，如果没有的话，那通常就是开发的时候，实例化以后去手动挂载，到那个时候也会将实例挂载到DOM上。挂载入口是从调用$mount方法开始。")]),t._v(" "),n("p",[n("code",[t._v("$mount")]),t._v("方法主要有两个版本，只有runtime运行时的版本（核心是调用"),n("code",[t._v("mountComponent")]),t._v("，然后执行render方法生成vnode，调用update将vnode渲染为真实DOM），和带有compiler和runtime的版本。")]),t._v(" "),n("ul",[n("li",[t._v("前者通常用在工程化项目上，使用webpack时集成了Vue-loader，会把template自动编译成render function，就不需要在运行的时候先进行编译。然后不同的平台，使用的运行时不一样，比如web浏览器和weex移动端。")])]),t._v(" "),n("p",[t._v("有compiler的版本，如果没有定义render function，就会将template模板字符串parse解析生成AST，然后优化AST，标记AST中可以优化的节点，也就是不涉及数据变化的静态节点在每次渲染时生成的DOM都是一致的，比如纯文本节点，使用了v-pre指令的节点。")]),t._v(" "),n("ul",[n("li",[t._v("hand-written render functions / JSX")]),t._v(" "),n("li",[t._v("parse 的过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来实现构造 AST 树。")]),t._v(" "),n("li",[t._v("optimize优化的过程：会进行两轮深度遍历，遍历每一个元素节点，先标记出静态子节点，然后根据这个结果再标记出静态根节点。在第一次render的时候，静态根节点的vnode就会被缓存，在第一次patch生成DOM以后的每次patch都会跳过静态根节点。")])]),t._v(" "),n("p",[t._v("然后根据优化后的AST，generate生成render function。")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("使用了with语法拼接generate生成的代码，变为一串字符串形式的可执行代码。")])]),t._v(" "),n("li",[n("p",[t._v("generate的过程：先处理一下options，然后调用genElement处理指令、slot、动态组件等，对每个AST节点生成代码。")])])]),t._v(" "),n("p",[t._v("执行完成编译的逻辑以后，会去执行runtime版本的mount，就是去调用mountComponent方法，触发生命周期的beforeMount钩子，创建一个Render Watcher，执行watcher的getter方法，这将执行render function，然后访问其中每个使用到的实例属性，触发这些属性的getter，用来依赖收集。然后将执行生成的vnode传给update方法，最终渲染成真实DOM。")]),t._v(" "),n("ul",[n("li",[t._v("vnode、vdom：每个组件或节点都会被编译成render function，执行render函数时会调用createElement方法生成VNode，整个页面的组件树就会变成由一个个VNode组成的VNode树，建立起来的这棵树也就是Virtual DOM。vnode和vdom都是在用一个JavaScript对象去描述DOM树，是一种抽象描述，包含了创建真实DOM所需要的信息。\n"),n("ul",[n("li",[t._v("Virtual DOM是Vue2版本的重大更新，它的优势在于，对比真实DOM，创建虚拟DOM的资源消耗更低，不需要频繁操作DOM，执行效率更高。还有个好处在于，虚拟DOM可以被用于实现SSR，以及跨平台的UI渲染，例如web端和移动端。")])])]),t._v(" "),n("li",[t._v("Render Watcher的getter方法updateComponent，会去调用_update方法，核心是调用patch方法.")]),t._v(" "),n("li",[t._v("patch方法中，如果是首次渲染，则直接调用createElm方法创建一个节点，最后使用浏览器的DOM API添加到真实DOM上，完成挂载，触发生命周期的mounted钩子。如果是更新响应式数据触发组件更新的情况，就会在内部使用sameVNode判断新旧VNode是否相同，来使用不同的更新逻辑。\n"),n("ul",[n("li",[t._v("如果新旧vnode不同，更新的逻辑就是创建新节点，更新父的占位符节点，删除旧节点（触发生命周期destroy钩子）\n"),n("ul",[n("li",[t._v("占位符节点指的是组件vnode的tag，用来标识这一串的vnode是属于哪一个组件的")])])]),t._v(" "),n("li",[t._v("如果新旧vnode相同，会调用patchVnode，更新的逻辑就是将新vnode patch到旧vnode上去。在patch前后会执行对应的钩子函数。最复杂的情况是都存在子节点，就需要调用updateChildren来Diff遍历比较子节点，通过调整节点顺序复用旧节点，以及插入和删除节点，最终完成DOM更新。")])])])]),t._v(" "),n("h3",{attrs:{id:"响应式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#响应式"}},[t._v("#")]),t._v(" 响应式")]),t._v(" "),n("p",[t._v("重写数组原型方法，因为不能侦听到数组长度的变化，而数组的实例方法会中会影响原数组的方法只有有限的7个，再考虑到数组可扩展性很强，如果数据量很大，重写原型方法这种方式性价比很高。")]),t._v(" "),n("h3",{attrs:{id:"组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),n("h3",{attrs:{id:"生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")])])}),[],!1,null,null,null);e.default=s.exports}}]);