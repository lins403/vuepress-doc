(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{506:function(a,v,t){"use strict";t.r(v);var _=t(43),e=Object(_.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"内存管理与垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存管理与垃圾回收"}},[a._v("#")]),a._v(" 内存管理与垃圾回收")]),a._v(" "),t("blockquote",[t("p",[a._v("JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收")])]),a._v(" "),t("h2",{attrs:{id:"内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),t("h3",{attrs:{id:"生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),t("ol",[t("li",[a._v("分配内存\n"),t("ul",[t("li",[a._v("声明变量、函数、对象的时候，系统会自动为它们分配内存")])])]),a._v(" "),t("li",[a._v("使用内存")]),a._v(" "),t("li",[a._v("释放内存")])]),a._v(" "),t("h3",{attrs:{id:"栈内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈内存"}},[a._v("#")]),a._v(" 栈内存")]),a._v(" "),t("ul",[t("li",[a._v("原始值（String、Number、Boolean、null、undefined、Symbol），占据空间小、大小固定")])]),a._v(" "),t("h3",{attrs:{id:"堆内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆内存"}},[a._v("#")]),a._v(" 堆内存")]),a._v(" "),t("ul",[t("li",[a._v("引用值（不是所有的引用类型都存储在堆中），占据空间大、大小不固定")]),a._v(" "),t("li",[a._v("闭包中的变量")])]),a._v(" "),t("h3",{attrs:{id:"内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[a._v("#")]),a._v(" 内存泄漏")]),a._v(" "),t("ul",[t("li",[a._v("全局变量")]),a._v(" "),t("li",[a._v("定时器（setInterval）")]),a._v(" "),t("li",[a._v("闭包")])]),a._v(" "),t("h2",{attrs:{id:"栈内存和堆内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈内存和堆内存"}},[a._v("#")]),a._v(" 栈内存和堆内存")]),a._v(" "),t("p",[t("strong",[a._v("multithreading")])]),a._v(" "),t("ul",[t("li",[a._v("每个线程都有自己的栈，而堆是共享的")])]),a._v(" "),t("p",[t("strong",[a._v("store")])]),a._v(" "),t("ul",[t("li",[a._v("原始类型存储在栈中，引用类型存储在堆中")])]),a._v(" "),t("p",[t("strong",[a._v("size")])]),a._v(" "),t("ul",[t("li",[a._v("栈内存在线程创建时分配，被设置为固定大小，不能再多分配空间")]),a._v(" "),t("li",[a._v("堆内存在应用启动时分配，可以被动态分配内存大小（can grow as space is needed (the allocator requests more memory from the operating system).）")])]),a._v(" "),t("p",[t("strong",[a._v("faster")])]),a._v(" "),t("ul",[t("li",[a._v("栈比堆快得多，这是因为在栈上分配内存就像向上移动栈指针一样简单")]),a._v(" "),t("li",[a._v("栈上的频繁使用的数据会被处理器缓存（tends to be mapped to the processor's cache），从而更快")]),a._v(" "),t("li",[a._v("堆的分配和回收更复杂（much more complex bookkeeping），且操作还需要多线程之间的协调（coordination）")]),a._v(" "),t("li",[a._v("栈内分配和回收空间都只需要移动指针（栈指针？帧指针？）")])]),a._v(" "),t("p",[t("strong",[a._v("memory deallocated")])]),a._v(" "),t("ul",[t("li",[a._v("变量超出范围时，栈上的数据会被自动回收")]),a._v(" "),t("li",[a._v("堆上的数据会被一直保留，需要程序员手动删除，或者语言提供"),t("strong",[a._v("garbage collection")]),a._v("帮助自动回收")])]),a._v(" "),t("p",[t("strong",[a._v("wrong")])]),a._v(" "),t("ul",[t("li",[a._v("栈会导致"),t("em",[a._v("stack overflow")]),a._v("，而堆会出现内存碎片化 "),t("em",[a._v("fragmentation")]),a._v("，导致没有足够的连续空间用于存储")])]),a._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"http://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"),t("OutboundLink")],1)])]),a._v(" "),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("h4",{attrs:{id:"内存生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存生命周期"}},[a._v("#")]),a._v(" 内存生命周期")]),a._v(" "),t("ol",[t("li",[a._v("内存分配")]),a._v(" "),t("li",[a._v("使用内存")]),a._v(" "),t("li",[a._v("释放内存\n"),t("ul",[t("li",[a._v("JavaScript通过 "),t("mark",[a._v("自动内存管理")]),a._v(" 实现内存分配和闲置资源回收")])])])]),a._v(" "),t("h3",{attrs:{id:"回收策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收策略"}},[a._v("#")]),a._v(" 回收策略")]),a._v(" "),t("p",[a._v("基本思路是，确定哪个变量不会再使用，然后释放它占用的内存。")]),a._v(" "),t("p",[a._v("这个过程是周期性的，即垃圾回收程序每隔一定时间(或者说在代码执行过程中某个预定的收集时间)就会自动运行。")]),a._v(" "),t("h4",{attrs:{id:"特殊"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特殊"}},[a._v("#")]),a._v(" 特殊")]),a._v(" "),t("ul",[t("li",[a._v("全局变量\n"),t("ul",[t("li",[a._v("全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器；在这之前，上下文的变量对象中的变量，即全局变量，不会被当成垃圾回收")])])]),a._v(" "),t("li",[a._v("闭包中的变量\n"),t("ul",[t("li",[a._v("闭包中的变量并不保存中栈内存中，而是保存在堆内存中")])])])]),a._v(" "),t("h3",{attrs:{id:"标记策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记策略"}},[a._v("#")]),a._v(" 标记策略")]),a._v(" "),t("ol",[t("li",[t("code",[a._v("引用计数")]),a._v(" (reference counting)\n"),t("ul",[t("li",[a._v("垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存")]),a._v(" "),t("li",[a._v("不能解决循环引用的问题（objectA 和 objectB 通过各自的属性相互引用），可能导致内存泄漏")])])]),a._v(" "),t("li",[t("code",[a._v("标记清理")]),a._v(" (mark-and-sweep)\n"),t("ul",[t("li",[a._v("最常用的垃圾回收策略，先给当前不使用的值加上标记，再回来回收它们的内存")]),a._v(" "),t("li",[a._v("垃圾回收程序会在运行的时候，给存储在内存中的所有变量都加上标记，从根部出发将能触及到的对象的标记清除（将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉），销毁那些带标记的值（因为任何在上下文中的变量都访问不到它们了），并回收它们所占用的内存空间。")])])])]),a._v(" "),t("h3",{attrs:{id:"性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[a._v("#")]),a._v(" 性能")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("对浏览器而言，调度垃圾回收程序方面的问题会导致性能下降")])]),a._v(" "),t("li",[t("p",[a._v("对开发者而言，理论上如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("赋值 "),t("code",[a._v("null")]),a._v("，解除对象的引用。")]),a._v(" "),t("ul",[t("li",[a._v("为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用")])])]),a._v(" "),t("li",[t("p",[a._v("静态分配（内存）策略")])])])])]),a._v(" "),t("h2",{attrs:{id:"v8垃圾回收机制♻️"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制♻️"}},[a._v("#")]),a._v(" V8垃圾回收机制♻️")]),a._v(" "),t("ul",[t("li",[a._v("栈回收\n"),t("ul",[t("li",[a._v("在使用栈顶指针进行切换执行上下文的时候，栈顶内容自动被回收，这就是"),t("strong",[a._v("栈的垃圾回收机制")])])])]),a._v(" "),t("li",[a._v("堆回收\n"),t("ul",[t("li",[a._v("V8的垃圾回收策略主要基于"),t("strong",[a._v("分代式垃圾回收机制")]),a._v("，在堆中把存储空间分为"),t("strong",[a._v("新生代和老生代")]),a._v("两个部分，分别予以实施不同的回收算法")])])])]),a._v(" "),t("h3",{attrs:{id:"垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),t("p",[a._v("现代的垃圾回收算法中，按照对象的存活时间，将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qM2dmaWNpY3lPdmFzbFg2YUtoM05UeDBQcXlpYlFLVkRqandyMWVRZDBMY3ZZMTVpYkd0eTl2bXZpYU00TGpLaWFzNnlmazI1WHlibkZGSk1sVXZzNUJZRFZ3US82NDA?x-oss-process=image/format,png",alt:""}})]),a._v(" "),t("h4",{attrs:{id:"新生代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[a._v("#")]),a._v(" 新生代")]),a._v(" "),t("ul",[t("li",[a._v("新生成的体积没有过大的对象、存活时间较短的对象（新生成的体积较大的对象被直接分配到大对象空间(Large Object Space) ）")]),a._v(" "),t("li",[a._v("新生代内存空间比老生代小得多")])]),a._v(" "),t("h5",[a._v("回收算法")]),a._v(" "),t("ul",[t("li",[a._v("将堆内存一分而二，其中一个处于使用状态的空间称为From空间，另一个处于闲置状态的空间称为To空间。给新对象分配内存时在from空间中进行分配，当开始进行垃圾回收时，释放 From 空间中非存活对象所占用的空间，将存活对象复制到 To 空间，完成以后To空间和From空间角色互换。所以，新生代的垃圾回收，相当于将内存空间中的存活对象，在划分的两个分区之间进行复制。")]),a._v(" "),t("li",[a._v("新生代垃圾回收的 Scavenge 算法，通过牺牲空间换时间的算法非常适合生命周期短的新生代。")])]),a._v(" "),t("h4",{attrs:{id:"老生代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老生代"}},[a._v("#")]),a._v(" 老生代")]),a._v(" "),t("blockquote",[t("p",[a._v("当一个对象符合条件时，会被从新生代晋升到老生代中进行管理，这时需要采用新的算法进行垃圾回收。")]),a._v(" "),t("blockquote",[t("p",[a._v("对象晋升的条件主要有两个")]),a._v(" "),t("ol",[t("li",[a._v("一个是对象是否经历过 Scanvenge 回收（经过多次复制依然存活，则生命周期较长）")]),a._v(" "),t("li",[a._v("一个是 To 空间的内存占用超过限制（占满25%时？）")])])])]),a._v(" "),t("ul",[t("li",[a._v("存活时间较长的对象，或常驻内存的对象")]),a._v(" "),t("li",[a._v("指针空间（Old pointer space）: 存储的对象含有指向其他对象的指针")]),a._v(" "),t("li",[a._v("数据空间（Old data space）：存储的对象仅包含数据，无指向其他对象的指针")]),a._v(" "),t("li",[a._v("全局作用域中的变量不会执行垃圾回收过程，此类对象将会常驻内存（在老生代空间）。如果需要释放该类对象空间，只能通过delete，或重新赋值变量为undefind或者null来释放对象的引用。")])]),a._v(" "),t("h5",[a._v("回收算法")]),a._v(" "),t("p",[t("code",[a._v("Mark-Sweep")]),a._v(" 标记清除")]),a._v(" "),t("ul",[t("li",[a._v("标记堆内存中的所有存活对象，垃圾回收时清除那些没有被标记的对象\n"),t("ul",[t("li",[a._v("给存储在内存中的所有变量都加上标记，从根部出发，将能触及到的对象的标记清除，没有有标记的对象会被垃圾回收")])])]),a._v(" "),t("li",[a._v("但标记清除会造成一个问题，就是在清除过后会导致内存不连续，造成内存碎片。在给一个较大对象分配内存时，如果没有任何一个内存碎片有足够的空间进行分配，就会导致提前触发垃圾回收，而这次回收是不必要的。")])]),a._v(" "),t("p",[t("code",[a._v("Mark-Compact")]),a._v(" 标记整理")]),a._v(" "),t("ul",[t("li",[a._v("在标记清除的过程中，标记整理会将存活的对象和需要清除的对象移动到两端。然后将其中一段需要清除的消灭掉，可以解决标记清除造成的内存碎片问题。")]),a._v(" "),t("li",[a._v("Mark-Compact 比 Mark-Sweep 增加了一个整理的概念，它的回收执行顺序是"),t("code",[a._v("标记—整理—清除")]),a._v("。所谓的整理概念是指在标记过程中，会将存活的对象都往一端移动，完成以后再对另一端，即需要被清除的空间进行垃圾回收")]),a._v(" "),t("li",[a._v("Mark-Compact算法执行后的内存空间更合理，但是因为需要移动对象，所以它的执行速度没有Mark-Sweep快。")])]),a._v(" "),t("h3",{attrs:{id:"回收算法优化-增量标记-incremental-marking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收算法优化-增量标记-incremental-marking"}},[a._v("#")]),a._v(" 回收算法优化——增量标记（Incremental Marking）")]),a._v(" "),t("p",[a._v("js是单线程语言，在垃圾回收的时候就会阻塞主线程的进行，尤其是在对老生代空间进行垃圾回收时，可能会导致明显的卡顿，所以v8采用增量标记的方法进行优化。本质上做的事，相当于"),t("strong",[a._v("将标记阶段分步骤进行")]),a._v("，标记一段后，就将主线程交还，用于继续执行应用逻辑，标记阶段结束之后，进入循环进行内存碎片的整理。")]),a._v(" "),t("ul",[t("li",[a._v("scavenge 算法 mark-sweep 及 mark-compact 都会导致 stop-the-world (全停顿，在执行回收时会停止应用逻辑)。而全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过 100ms，因此 V8 引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在 5ms 内，每运行一段时间标记动作， 就让 JavaScript 程序执行一会儿， 如此交替，明显地提高了程序流畅性，在一定程度上避免了长时间卡顿。")])]),a._v(" "),t("h2",{attrs:{id:"内存泄漏-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏-2"}},[a._v("#")]),a._v(" 内存泄漏")]),a._v(" "),t("p",[a._v("由于不当的代码，有时候难免会发生内存泄漏，常见的有四个场景：")]),a._v(" "),t("ol",[t("li",[a._v("意外的全局变量")]),a._v(" "),t("li",[a._v("闭包引用\n"),t("ul",[t("li",[a._v("闭包会使得已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。")]),a._v(" "),t("li",[a._v("定时器的回调通常也是个闭包，如果定时器没有被清理，其访问的变量也会被一直保留")])])]),a._v(" "),t("li",[a._v("事件绑定\n"),t("ul",[t("li",[a._v("在页面初始化时绑定了事件监听，但是在页面离开的时候未清除事监听")])])]),a._v(" "),t("li",[a._v("缓存爆炸")]),a._v(" "),t("li",[a._v("脱离 DOM 的引用\n"),t("ul",[t("li",[a._v("获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以引用也无法被回收。")]),a._v(" "),t("li",[a._v("可以使用WeakMap结构来添加引用关系，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除")])])])]),a._v(" "),t("h2",{attrs:{id:"recap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#recap"}},[a._v("#")]),a._v(" Recap")]),a._v(" "),t("p",[a._v("【V8 引擎的垃圾回收机制】TODO")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n复制代码\n")])])]),t("h1",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("p",[a._v("《JavaScript高级程序设计》")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6854573211716321287#heading-3",target:"_blank",rel:"noopener noreferrer"}},[a._v("浏览器v8引擎 > js的垃圾回收机制"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000038175558",target:"_blank",rel:"noopener noreferrer"}},[a._v("一起来看Javascript的垃圾回收机制"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6844904097703804936",target:"_blank",rel:"noopener noreferrer"}},[a._v("JS垃圾回收，这次可以看懂了（带图警告）"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);