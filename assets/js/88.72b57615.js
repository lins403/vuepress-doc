(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{489:function(t,v,_){"use strict";_.r(v);var l=_(43),a=Object(l.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串"}},[t._v("#")]),t._v(" 串")]),t._v(" "),_("p",[t._v("字符串，主串、子串、串长")]),t._v(" "),_("ul",[_("li",[t._v("串的逻辑结构和线性表极为相似，区别仅在于串的数据对象只能为字符集，")]),t._v(" "),_("li",[t._v("且串的基本操作通常以子串为操作对象，如查找、删除、插入一个子串等")])]),t._v(" "),_("h2",{attrs:{id:"存储结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储结构"}},[t._v("#")]),t._v(" 存储结构")]),t._v(" "),_("ul",[_("li",[t._v("定长顺序存储")]),t._v(" "),_("li",[t._v("堆分配存储\n"),_("ul",[_("li",[t._v("存储空间是在程序运行过程中动态分配得到的")])])]),t._v(" "),_("li",[t._v("块链存储\n"),_("ul",[_("li",[t._v("由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点可以存放一个或多个字符")])])])]),t._v(" "),_("h2",{attrs:{id:"模式匹配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模式匹配"}},[t._v("#")]),t._v(" 模式匹配")]),t._v(" "),_("p",[t._v("子串的定位操作，求的是子串（模式串）在主串中的位置")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("简单的模式匹配算法")]),t._v(" "),_("ul",[_("li",[t._v("暴力匹配")]),t._v(" "),_("li",[t._v("时间复杂度近似为O(m+n)，但理论时间复杂度为O(mn)")])])]),t._v(" "),_("li",[_("p",[t._v("改进——KMP算法")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("部分匹配值表")])]),t._v(" "),_("li",[_("p",[t._v("next数组。移动位数 = 已匹配的字符数 - 对应的部分匹配值")])]),t._v(" "),_("li",[_("p",[t._v("时间复杂度为O(m+n)")])])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);