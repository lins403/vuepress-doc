(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{588:function(e,t,v){"use strict";v.r(t);var r=v(43),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"概要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[e._v("#")]),e._v(" 概要")]),e._v(" "),v("h2",{attrs:{id:"一、数据驱动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、数据驱动"}},[e._v("#")]),e._v(" 一、数据驱动")]),e._v(" "),v("p",[e._v("【做一个简单的梳理，从数据到DOM视图】")]),e._v(" "),v("h2",{attrs:{id:"二、响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、响应式原理"}},[e._v("#")]),e._v(" 二、响应式原理")]),e._v(" "),v("h3",{attrs:{id:"observer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#observer"}},[e._v("#")]),e._v(" Observer")]),e._v(" "),v("ul",[v("li",[e._v("响应式的核心，调度数据绑定，和数据变化的发布订阅。")]),e._v(" "),v("li",[e._v("数据劫持。给每个要被观察的对象添加一个observer实例，使用"),v("code",[e._v("Object.defineProperty")]),e._v("给要观察对象的每个属性添加getter和setter，将其变为响应式对象。一旦属性被访问或者更新，就可以追踪到这些变化。")])]),e._v(" "),v("h3",{attrs:{id:"watcher"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watcher"}},[e._v("#")]),e._v(" Watcher")]),e._v(" "),v("ul",[v("li",[e._v("观察者。共有4种类型的watcher实例，在派发更新时，调用watcher中的方法进行逻辑处理")])]),e._v(" "),v("h3",{attrs:{id:"dep"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dep"}},[e._v("#")]),e._v(" Dep")]),e._v(" "),v("ul",[v("li",[e._v("Dependency")]),e._v(" "),v("li",[e._v("给对象的每个属性添加一个dep实例，每个 dep 中都维护了一个用于管理所有订阅 watcher 的 subscribers")])]),e._v(" "),v("h4",{attrs:{id:"依赖收集、派发更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#依赖收集、派发更新"}},[e._v("#")]),e._v(" 依赖收集、派发更新")]),e._v(" "),v("ul",[v("li",[e._v("当对象触发getter时，通过 "),v("code",[e._v("dep.depend()")]),e._v(" 进行依赖收集，将 watcher 实例添加进 subscribers 容器中。(容器是dep实例的一个属性，watcher实例是通过 Dep.target 的方式插入)")]),e._v(" "),v("li",[e._v("当对象数据发生变化时，触发setter，然后调用 "),v("code",[e._v("dep.notify()")]),e._v(" 进行派发更新，遍历 subscribers 容器中的每个 watcher，然后调用 watcher 中的方法进行更新，完成相应的逻辑处理。")])]),e._v(" "),v("h4",{attrs:{id:"nexttick"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" nextTick")]),e._v(" "),v("ul",[v("li",[e._v("异步更新机制")]),e._v(" "),v("li",[e._v("响应式数据发生变化时会派发更新，但是把 watcher 推送到一个队列中，将同一事件循环内的所有数据变化缓存起来，在 "),v("code",[e._v("nextTick")]),e._v(" 后才会真正执行 watcher 的回调函数。这样做的好处是一个watcher被重复触发，但是也只需要进行一次DOM更新。\n"),v("ul",[v("li",[e._v("Vue 在更新 DOM 时是"),v("strong",[e._v("异步")]),e._v("执行的。只要侦听到数据变化，Vue 将开启一个队列 (queueWatcher)，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。")])])]),e._v(" "),v("li",[e._v("只是过滤掉重复的watcher，每次只要修改响应式数据，就会派发更新给watcher，即使是重复修改成同一个数据。")]),e._v(" "),v("li",[e._v("由于DOM异步更新的特性，所以不能再当前事件循环中直接操作这个DOM，可以在"),v("code",[e._v("$nextTick")]),e._v("的回调函数中操作更新后的DOM。")])]),e._v(" "),v("h4",{attrs:{id:"computed-watch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed-watch"}},[e._v("#")]),e._v(" computed & watch")]),e._v(" "),v("ul",[v("li",[e._v("computed 计算属性本质上是 "),v("code",[e._v("computed watcher")]),e._v("，当计算的最终值发生变化时才会触发 watcher 并重新渲染，算是一种优化。")]),e._v(" "),v("li",[e._v("而 watch 侦听属性本质上是 "),v("code",[e._v("user watcher")]),e._v("，但通过设置 "),v("code",[e._v("deep")]),e._v(" 或者 "),v("code",[e._v("immediate")]),e._v("，又可以衍生出深度遍历对象属性的 "),v("code",[e._v("deep watcher")]),e._v(" ，与在当前 Tick 中同步执行 watcher 回调函数的 "),v("code",[e._v("sync watcher")])])]),e._v(" "),v("h2",{attrs:{id:"三、组件化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、组件化"}},[e._v("#")]),e._v(" 三、组件化")]),e._v(" "),v("ul",[v("li",[e._v("$mount实例挂载")]),e._v(" "),v("li",[e._v("merge options &合并策略")]),e._v(" "),v("li",[e._v("生命周期")]),e._v(" "),v("li",[e._v("组件注册")]),e._v(" "),v("li",[e._v("异步组件")])]),e._v(" "),v("h2",{attrs:{id:"四、编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、编译"}},[e._v("#")]),e._v(" 四、编译")]),e._v(" "),v("ul",[v("li",[e._v("compile（parse、optimize、codegen）")]),e._v(" "),v("li",[e._v("VDOM & VNode")]),e._v(" "),v("li",[e._v("Diff")])]),e._v(" "),v("h2",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),v("p",[e._v("初始化 Vue 实例 ---\x3e 编译 template 模板 ---\x3e 挂载实例到 DOM ---\x3e 在数据变化时更新 DOM")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th"),e._v(" "),v("th",[e._v("调用时机")]),e._v(" "),v("th",[e._v("补充")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("beforeCreate")]),e._v(" "),v("td",[e._v("在实例初始化之后，进行数据侦听和事件/侦听器的配置之前")]),e._v(" "),v("td",[e._v("initState之前")])]),e._v(" "),v("tr",[v("td",[e._v("created")]),e._v(" "),v("td",[e._v("在实例创建完成后被立即同步调用")]),e._v(" "),v("td",[e._v("initState之后；"),v("br"),e._v("可以访问到数据")])]),e._v(" "),v("tr",[v("td",[e._v("beforeMount")]),e._v(" "),v("td",[e._v("在挂载开始之前被调用：相关的 "),v("code",[e._v("render")]),e._v(" 函数首次被调用")]),e._v(" "),v("td",[e._v("在template编译成render function之后、创建Render Watcher之前")])]),e._v(" "),v("tr",[v("td",[e._v("mounted")]),e._v(" "),v("td",[e._v("在实例被挂载（生成 DOM 树）后调用")]),e._v(" "),v("td",[e._v("可以访问到 DOM；"),v("br"),e._v("执行顺序是先子后父")])]),e._v(" "),v("tr",[v("td",[e._v("beforeUpdate")]),e._v(" "),v("td",[e._v("在数据发生改变后，DOM 被更新之前")]),e._v(" "),v("td",[e._v("生成 Virtual DOM 之后、生成 real DOM 树之前")])]),e._v(" "),v("tr",[v("td",[e._v("updated")]),e._v(" "),v("td",[e._v("在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后")]),e._v(" "),v("td",[e._v("watcher 的回调执行完毕后；"),v("br"),e._v("执行顺序是先子后父；"),v("br"),e._v("组件 DOM 已经更新但不会保证所有的子组件也都被重新渲染完毕，要使用$nextTick")])]),e._v(" "),v("tr",[v("td",[e._v("activated")]),e._v(" "),v("td",[e._v("被 keep-alive 缓存的组件激活时调用")]),e._v(" "),v("td",[e._v("生成 DOM 树之后（keep-alive）")])]),e._v(" "),v("tr",[v("td",[e._v("deactivated")]),e._v(" "),v("td",[e._v("被 keep-alive 缓存的组件失活时调用")]),e._v(" "),v("td",[e._v("实例销毁时（keep-alive）")])]),e._v(" "),v("tr",[v("td",[e._v("beforeDestroy")]),e._v(" "),v("td",[e._v("实例销毁之前调用")]),e._v(" "),v("td",[e._v("在这一步，实例仍然完全可用")])]),e._v(" "),v("tr",[v("td",[e._v("destroyed")]),e._v(" "),v("td",[e._v("实例销毁后调用")]),e._v(" "),v("td",[e._v("解绑指令、移除事件监听器、销毁子组件实例")])]),e._v(" "),v("tr",[v("td",[e._v("errorCaptured")]),e._v(" "),v("td",[e._v("在捕获一个来自后代组件的错误时被调用")]),e._v(" "),v("td",[e._v("可以返回 false 以阻止该错误继续向上传播")])])])]),e._v(" "),v("blockquote",[v("p",[e._v("父子组件的生命周期顺序：父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted（因为"),v("code",[e._v("insertedVnodeQueue")]),e._v(" 的添加顺序是先子后父）")])]),e._v(" "),v("p",[v("strong",[e._v("服务器端渲染期间")]),e._v("只有beforeCreate、created、errorCaptured会被调用")]),e._v(" "),v("p",[e._v("如果组件的模板中没有用到的数据被更新，即使是更改响应式数据但不会触发DOM更新时，就不会触发beforeUpdate和updated。")]),e._v(" "),v("h1",{attrs:{id:"资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[e._v("#")]),e._v(" 资料")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://ustbhuangyi.github.io/vue-analysis/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js 技术揭秘"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/answershuto/learnVue",target:"_blank",rel:"noopener noreferrer"}},[e._v("answershuto/learnVue: Vue.js 源码解析"),v("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);