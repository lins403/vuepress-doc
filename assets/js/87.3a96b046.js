(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{488:function(a,t,v){"use strict";v.r(t);var _=v(43),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"栈和队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈和队列"}},[a._v("#")]),a._v(" 栈和队列")]),a._v(" "),v("h2",{attrs:{id:"栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[a._v("#")]),a._v(" 栈")]),a._v(" "),v("blockquote",[v("p",[a._v("栈的内部实现原理其实就是数组或链表的操作")]),a._v(" "),v("p",[a._v("而之所以引入 栈 这个概念，是为了将程序设计问题模型化")]),a._v(" "),v("p",[a._v("用高层的模块指导特定行为（栈的先进后出特性），划分了不同关注层次，使得思考范围缩小。")]),a._v(" "),v("p",[a._v("更加聚焦于我们致力解决的问题核心，简化了程序设计的问题")])]),a._v(" "),v("p",[a._v("栈顶：线性表允许进行插入删除的那一端")]),a._v(" "),v("p",[a._v("栈底：固定的，不允许插入删除")]),a._v(" "),v("h3",{attrs:{id:"顺序存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#顺序存储"}},[a._v("#")]),a._v(" 顺序存储")]),a._v(" "),v("h4",{attrs:{id:"顺序栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#顺序栈"}},[a._v("#")]),a._v(" 顺序栈")]),a._v(" "),v("ul",[v("li",[a._v("栈顶指针：s.top，初始时设置s.top=-1；栈顶元素：s.data[s.top]。")]),a._v(" "),v("li",[a._v("入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素")]),a._v(" "),v("li",[a._v("出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1")]),a._v(" "),v("li",[a._v("栈空条件："),v("code",[a._v("s.top==-1")]),a._v("；栈满条件："),v("code",[a._v("S.top==MaxSize-1")]),a._v("；栈长："),v("code",[a._v("s.top+1")]),a._v("。")])]),a._v(" "),v("h4",{attrs:{id:"共享栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享栈"}},[a._v("#")]),a._v(" 共享栈")]),a._v(" "),v("ul",[v("li",[a._v("利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，仅当两个栈顶指针相邻时判断为栈满。")]),a._v(" "),v("li",[a._v("为了更有效的利用存储空间，两个栈的空间相互调节")])]),a._v(" "),v("h3",{attrs:{id:"链式存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链式存储"}},[a._v("#")]),a._v(" 链式存储")]),a._v(" "),v("h4",{attrs:{id:"链栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链栈"}},[a._v("#")]),a._v(" 链栈")]),a._v(" "),v("ul",[v("li",[a._v("通常采用单链表实现")]),a._v(" "),v("li",[a._v("便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况")]),a._v(" "),v("li",[a._v("便于结点的插入和删除")])]),a._v(" "),v("h2",{attrs:{id:"队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[a._v("#")]),a._v(" 队列")]),a._v(" "),v("p",[a._v("队头指针front，队尾指针rear")]),a._v(" "),v("h3",{attrs:{id:"顺序存储-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#顺序存储-2"}},[a._v("#")]),a._v(" 顺序存储")]),a._v(" "),v("h4",{attrs:{id:"顺序队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#顺序队列"}},[a._v("#")]),a._v(" 顺序队列")]),a._v(" "),v("ul",[v("li",[a._v("初始状态（队空条件）：Q.front == Q.rear == 0。")]),a._v(" "),v("li",[a._v("进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。")]),a._v(" "),v("li",[a._v("出队操作：队不空时，先取队头元素值，再将队头指针加1。（队尾指针没变，）会导致Q.rear==Maxsize但实际依然有空位置的“假溢出”情况")])]),a._v(" "),v("h4",{attrs:{id:"循环队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#循环队列"}},[a._v("#")]),a._v(" 循环队列")]),a._v(" "),v("ul",[v("li",[a._v("即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，这可以利用除法取余运算（号）来实现")]),a._v(" "),v("li",[a._v("队首指针进1： Q.front=(Q.front+1)MaxSize。队尾指针进1：Q.rear=(Q.rear+1)MaxSize。")]),a._v(" "),v("li",[a._v("区分队空和队满")])]),a._v(" "),v("h3",{attrs:{id:"链式存储-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链式存储-2"}},[a._v("#")]),a._v(" 链式存储")]),a._v(" "),v("h4",{attrs:{id:"链队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链队列"}},[a._v("#")]),a._v(" 链队列")]),a._v(" "),v("ul",[v("li",[a._v("实际上是一个同时带有队头指针和队尾指针的单链表。队头结点、队尾结点")])]),a._v(" "),v("h4",{attrs:{id:"双端队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双端队列"}},[a._v("#")]),a._v(" 双端队列")]),a._v(" "),v("ul",[v("li",[a._v("允许两端都可以进行入队和出队操作")])]),a._v(" "),v("h2",{attrs:{id:"栈和队列的应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈和队列的应用"}},[a._v("#")]),a._v(" 栈和队列的应用")]),a._v(" "),v("h3",{attrs:{id:"栈的应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈的应用"}},[a._v("#")]),a._v(" 栈的应用")]),a._v(" "),v("ul",[v("li",[a._v("括号匹配")]),a._v(" "),v("li",[a._v("表达式求值")]),a._v(" "),v("li",[a._v("递归\n"),v("ul",[v("li",[a._v("递归的精髓在于能否将原始问题转换成相同属性但规模较小的问题")]),a._v(" "),v("li",[a._v("递归次数过多容易造成栈溢出")]),a._v(" "),v("li",[a._v("递归调用过程中包括很多重复的计算，效率低下。但优点是代码简单容易理解")])])])]),a._v(" "),v("h3",{attrs:{id:"队列的应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#队列的应用"}},[a._v("#")]),a._v(" 队列的应用")]),a._v(" "),v("ul",[v("li",[a._v("层次遍历\n"),v("ul",[v("li",[a._v("逐层或逐行处理的问题")])])]),a._v(" "),v("li",[a._v("操作系统\n"),v("ul",[v("li",[a._v("缓冲区，先进先出")]),a._v(" "),v("li",[a._v("CPU资源分配，操作请求")])])])]),a._v(" "),v("h2",{attrs:{id:"特殊矩阵的压缩存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特殊矩阵的压缩存储"}},[a._v("#")]),a._v(" 特殊矩阵的压缩存储")]),a._v(" "),v("p",[a._v("数组：由n个相同类型的数据元素构成的有限序列")]),a._v(" "),v("p",[a._v("矩阵的压缩存储：指为多个值相同的元素只分配中一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。")]),a._v(" "),v("p",[a._v("特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。")]),a._v(" "),v("ul",[v("li",[a._v("常见的特殊矩阵：对称矩阵、上（下）三角矩阵、对角矩阵")])]),a._v(" "),v("p",[a._v("特殊矩阵的压缩存储发：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。")]),a._v(" "),v("p",[a._v("稀疏矩阵：将非零元素构成一个三元组（行标、列标、值），然后再按某种规律存储这些三元组，可以采用数组存储或十字链表法存储")])])}),[],!1,null,null,null);t.default=r.exports}}]);