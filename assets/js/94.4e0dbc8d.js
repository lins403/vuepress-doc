(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{495:function(v,_,a){"use strict";a.r(_);var t=a(43),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[v._v("#")]),v._v(" 图")]),v._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[v._v("#")]),v._v(" 基本概念")]),v._v(" "),a("p",[v._v("线性表可以是空表，树可以是空树，但图不可以是空图")]),v._v(" "),a("ul",[a("li",[v._v("有向图、无向图")]),v._v(" "),a("li",[v._v("简单图：既不含平行边也不含自环的图")]),v._v(" "),a("li",[v._v("多重图")]),v._v(" "),a("li",[v._v("完全图（简单完全图）")]),v._v(" "),a("li",[v._v("连通、连通图、连通分量\n"),a("ul",[a("li",[v._v("连通图：任意两个顶点都是连通的")]),v._v(" "),a("li",[v._v("连通分量：无向图中的极大连通子图")])])]),v._v(" "),a("li",[v._v("强连通图、强连通分量\n"),a("ul",[a("li",[v._v("针对有向图而言")])])]),v._v(" "),a("li",[v._v("网\n"),a("ul",[a("li",[v._v("边上带有权值的图称为带权图，也称为网")])])]),v._v(" "),a("li",[v._v("有向无环图（Directed Acycline Graph，DAG）：一个有向图中不存在环")]),v._v(" "),a("li",[v._v("AOV网（Activity On Vertex NetWork）\n"),a("ul",[a("li",[v._v("用顶点表示活动，边表示活动（顶点）发生的先后关系。")]),v._v(" "),a("li",[v._v("AOV网的边不设权值，若存在边<a,b>则表示活动a必须发生在活动b之前。")])])]),v._v(" "),a("li",[v._v("AOE网（Activity On Edge Network）\n"),a("ul",[a("li",[v._v("是边表示活动的网，AOE网是带权有向无环图。边代表活动（边有权值），顶点代表所有指向它的边所代表的活动均已完成这一事件。")]),v._v(" "),a("li",[v._v("由于整个工程只有一个起点和一个终点，网中只有一个入度为0的点（源点）和一个出度为0的点（汇点）。")])])])]),v._v(" "),a("h2",{attrs:{id:"存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[v._v("#")]),v._v(" 存储")]),v._v(" "),a("h3",{attrs:{id:"邻接矩阵法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#邻接矩阵法"}},[v._v("#")]),v._v(" 邻接矩阵法")]),v._v(" "),a("ul",[a("li",[v._v("用一个一维数组存储顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），这个二维数组称为邻接矩阵")]),v._v(" "),a("li",[v._v("适合稠密图。当一个图为稀疏图时，会浪费大量的存储空间")]),v._v(" "),a("li",[v._v("很容易确定图中任意两个顶点之间是否有相连，但要确定图中有多少边，则必须按行、按列对每个时间进行检测，所花费的时间代价很大")])]),v._v(" "),a("h3",{attrs:{id:"邻接表法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#邻接表法"}},[v._v("#")]),v._v(" 邻接表法")]),v._v(" "),a("ul",[a("li",[v._v("大大减少了存储空间不必要的浪费")]),v._v(" "),a("li",[v._v("边表结点\n"),a("ul",[a("li",[v._v("对图中每个顶点建立一个单链表，这个单链表就称为该顶点的“边表”")]),v._v(" "),a("li",[v._v("邻接点域、指针域(指向下一条邻接边的指针域)")])])]),v._v(" "),a("li",[v._v("顶点表结点\n"),a("ul",[a("li",[v._v("边表的头指针和顶点的数据信息，采用顺序存储（称为“顶点表”）")]),v._v(" "),a("li",[v._v("顶点域、边表头指针(指向第一条邻接边的指针域)")])])]),v._v(" "),a("li",[v._v("给定一顶点，只需要读取它的邻接表，就能很容易找出它的所有邻边")]),v._v(" "),a("li",[v._v("在有向图的邻接表表示中，求一个给定顶点的出度，只需计算邻接表中的结点个数，但求其顶点的入度，则需遍历全部的邻接表")])]),v._v(" "),a("h3",{attrs:{id:"十字链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十字链表"}},[v._v("#")]),v._v(" 十字链表")]),v._v(" "),a("ul",[a("li",[v._v("既容易找到Vi为尾的弧，又容易找到为头的弧，因而容易求得顶点的出度和入度")]),v._v(" "),a("li",[v._v("图的十字链表表示不是唯一的，但一个十字链表表示确定一个图")])]),v._v(" "),a("h3",{attrs:{id:"邻接多重表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#邻接多重表"}},[v._v("#")]),v._v(" 邻接多重表")]),v._v(" "),a("ul",[a("li",[v._v("无向图的另一种链式存储结构")]),v._v(" "),a("li",[v._v("在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。")]),v._v(" "),a("li",[v._v("对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。")])]),v._v(" "),a("h3",{attrs:{id:"基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[v._v("#")]),v._v(" 基本操作")]),v._v(" "),a("ul",[a("li",[v._v("判断图G中是否存在边<x,y>")]),v._v(" "),a("li",[v._v("列出图G中与结点x邻接的边")]),v._v(" "),a("li",[v._v("插入顶点、删除顶点")]),v._v(" "),a("li",[v._v("...")])]),v._v(" "),a("h2",{attrs:{id:"遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[v._v("#")]),v._v(" 遍历")]),v._v(" "),a("h3",{attrs:{id:"广度优先搜索"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索"}},[v._v("#")]),v._v(" 广度优先搜索")]),v._v(" "),a("p",[v._v("Breadth-First-Search, BFS，按距离由近及远遍历，是二叉树层次遍历的扩展")]),v._v(" "),a("ul",[a("li",[v._v("BFS算法的性能分析\n"),a("ul",[a("li",[v._v("无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q")]),v._v(" "),a("li",[v._v("空间复杂度 Q(|V|)")]),v._v(" "),a("li",[v._v("时间复杂度")])])]),v._v(" "),a("li",[v._v("单资源最短路径问题")]),v._v(" "),a("li",[v._v("广度优先生成树\n"),a("ul",[a("li",[v._v("邻接矩阵存储表示是唯一的，邻接表存储表示不唯一")])])])]),v._v(" "),a("h3",{attrs:{id:"深度优先搜索"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索"}},[v._v("#")]),v._v(" 深度优先搜索")]),v._v(" "),a("p",[v._v("Depth-First-Search, DFS，类似于树的先序遍历")]),v._v(" "),a("ul",[a("li",[v._v("DFS算法的性能分析\n"),a("ul",[a("li",[v._v("递归算法，需要借助一个递归工作栈")]),v._v(" "),a("li",[v._v("空间复杂度 Q(|V|)")]),v._v(" "),a("li",[v._v("时间复杂度：邻接表 Q(|V|+|E|)，邻接矩阵存储 Q(|V|^2)")])])]),v._v(" "),a("li",[v._v("深度优先的生成树和生成森林\n"),a("ul",[a("li",[v._v("对连通图和非连通图调用DFS")])])])]),v._v(" "),a("h3",{attrs:{id:"图的遍历与图的连通性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图的遍历与图的连通性"}},[v._v("#")]),v._v(" 图的遍历与图的连通性")]),v._v(" "),a("p",[v._v("添加第2个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点")]),v._v(" "),a("h2",{attrs:{id:"应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[v._v("#")]),v._v(" 应用")]),v._v(" "),a("h3",{attrs:{id:"最小生成树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树"}},[v._v("#")]),v._v(" 最小生成树")]),v._v(" "),a("p",[v._v("Minimum-Spanning-Tree，MST，带权连通图，权值之和最小")]),v._v(" "),a("p",[a("strong",[v._v("最小生成树算法")])]),v._v(" "),a("ul",[a("li",[v._v("Prime算法\n"),a("ul",[a("li",[v._v("从顶点开始扩展")])])]),v._v(" "),a("li",[v._v("Kruskal算法\n"),a("ul",[a("li",[v._v("按权值的递增次序选择合适的边来构造最小生成树的办法")])])]),v._v(" "),a("li",[v._v("二者都是基于贪心算法的策略")])]),v._v(" "),a("h3",{attrs:{id:"最短路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最短路径"}},[v._v("#")]),v._v(" 最短路径")]),v._v(" "),a("p",[v._v("带权路径长度最短的路径")]),v._v(" "),a("p",[v._v("带权有向图G的最短路径问题一般分为2类：")]),v._v(" "),a("ol",[a("li",[v._v("单资源最短路径，即求图中某个顶点到其他各顶点的最短路径\n"),a("ul",[a("li",[v._v("Dijkstra算法")])])]),v._v(" "),a("li",[v._v("每对顶点间的最短路径\n"),a("ul",[a("li",[v._v("Floyd算法")])])])]),v._v(" "),a("h3",{attrs:{id:"拓扑排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拓扑排序"}},[v._v("#")]),v._v(" 拓扑排序")]),v._v(" "),a("p",[v._v("拓扑排序:在图论中,由一个有向无环图的顶点组成的序列,当且仅当满足下列条件时,称为该图的一个拓扑排序:")]),v._v(" "),a("p",[v._v("① 每个顶点出现且只出现一次。")]),v._v(" "),a("p",[v._v("② 若顶点A在序列中排在顶点B的前面,则在图中不存在从顶点B到顶点A的路径。")]),v._v(" "),a("p",[v._v("或定义为: 拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。每个AOV网都有一个或多个拓扑排序序列。")]),v._v(" "),a("h3",{attrs:{id:"关键路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键路径"}},[v._v("#")]),v._v(" 关键路径")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；")])]),v._v(" "),a("li",[a("p",[v._v("网中也仅存在一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。")])])]),v._v(" "),a("p",[v._v("从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。")]),v._v(" "),a("p",[v._v("完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。")])])}),[],!1,null,null,null);_.default=l.exports}}]);