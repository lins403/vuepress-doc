(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{500:function(t,v,a){"use strict";a.r(v);var _=a(43),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"内存管理与垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理与垃圾回收"}},[t._v("#")]),t._v(" 内存管理与垃圾回收")]),t._v(" "),a("blockquote",[a("p",[t._v("JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收")])]),t._v(" "),a("h2",{attrs:{id:"内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),a("h3",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("ol",[a("li",[t._v("分配内存\n"),a("ul",[a("li",[t._v("声明变量、函数、对象的时候，系统会自动为它们分配内存")])])]),t._v(" "),a("li",[t._v("使用内存")]),t._v(" "),a("li",[t._v("释放内存")])]),t._v(" "),a("h3",{attrs:{id:"栈内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈内存"}},[t._v("#")]),t._v(" 栈内存")]),t._v(" "),a("ul",[a("li",[t._v("原始值（String、Number、Boolean、null、undefined、Symbol），大小固定")])]),t._v(" "),a("h3",{attrs:{id:"堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆内存"}},[t._v("#")]),t._v(" 堆内存")]),t._v(" "),a("ul",[a("li",[t._v("引用值")]),t._v(" "),a("li",[t._v("闭包中的变量")])]),t._v(" "),a("h3",{attrs:{id:"内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),a("ul",[a("li",[t._v("全局变量")]),t._v(" "),a("li",[t._v("定时器（setInterval）")]),t._v(" "),a("li",[t._v("闭包")])]),t._v(" "),a("h2",{attrs:{id:"栈内存和堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈内存和堆内存"}},[t._v("#")]),t._v(" 栈内存和堆内存")]),t._v(" "),a("p",[a("strong",[t._v("multithreading")])]),t._v(" "),a("ul",[a("li",[t._v("每个线程都有自己的栈，而堆是共享的")])]),t._v(" "),a("p",[a("strong",[t._v("store")])]),t._v(" "),a("ul",[a("li",[t._v("原始类型存储在栈中，引用类型存储在堆中")])]),t._v(" "),a("p",[a("strong",[t._v("size")])]),t._v(" "),a("ul",[a("li",[t._v("栈内存在线程创建时分配，被设置为固定大小，不能再多分配空间")]),t._v(" "),a("li",[t._v("堆内存在应用启动时分配，可以被动态分配内存大小（can grow as space is needed (the allocator requests more memory from the operating system).）")])]),t._v(" "),a("p",[a("strong",[t._v("faster")])]),t._v(" "),a("ul",[a("li",[t._v("栈比堆快得多，这是因为在栈上分配内存就像向上移动栈指针一样简单")]),t._v(" "),a("li",[t._v("栈上的频繁使用的数据会被处理器缓存（tends to be mapped to the processor's cache），从而更快")]),t._v(" "),a("li",[t._v("堆的分配和回收更复杂（much more complex bookkeeping），且操作还需要多线程之间的协调（coordination）")]),t._v(" "),a("li",[t._v("栈内分配和回收空间都只需要移动指针（栈指针？帧指针？）")])]),t._v(" "),a("p",[a("strong",[t._v("memory deallocated")])]),t._v(" "),a("ul",[a("li",[t._v("变量超出范围时，栈上的数据会被自动回收")]),t._v(" "),a("li",[t._v("堆上的数据会被一直保留，需要程序员手动删除，或者语言提供"),a("strong",[t._v("garbage collection")]),t._v("帮助自动回收")])]),t._v(" "),a("p",[a("strong",[t._v("wrong")])]),t._v(" "),a("ul",[a("li",[t._v("栈会导致"),a("em",[t._v("stack overflow")]),t._v("，而堆会出现内存碎片化 "),a("em",[t._v("fragmentation")]),t._v("，导致没有足够的连续空间用于存储")])]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"http://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("h4",{attrs:{id:"内存生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存生命周期"}},[t._v("#")]),t._v(" 内存生命周期")]),t._v(" "),a("ol",[a("li",[t._v("内存分配")]),t._v(" "),a("li",[t._v("使用内存")]),t._v(" "),a("li",[t._v("释放内存\n"),a("ul",[a("li",[t._v("JavaScript通过 "),a("mark",[t._v("自动内存管理")]),t._v(" 实现内存分配和闲置资源回收")])])])]),t._v(" "),a("h3",{attrs:{id:"回收策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回收策略"}},[t._v("#")]),t._v(" 回收策略")]),t._v(" "),a("p",[t._v("基本思路是，确定哪个变量不会再使用，然后释放它占用的内存。")]),t._v(" "),a("p",[t._v("这个过程是周期性的，即垃圾回收程序每隔一定时间(或者说在代码执行过程中某个预定的收集时间)就会自动运行。")]),t._v(" "),a("h4",{attrs:{id:"特殊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特殊"}},[t._v("#")]),t._v(" 特殊")]),t._v(" "),a("ul",[a("li",[t._v("全局变量\n"),a("ul",[a("li",[t._v("全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器；在这之前，上下文的变量对象中的变量，即全局变量，不会被当成垃圾回收")])])]),t._v(" "),a("li",[t._v("闭包中的变量\n"),a("ul",[a("li",[t._v("闭包中的变量并不保存中栈内存中，而是保存在堆内存中")])])])]),t._v(" "),a("h3",{attrs:{id:"标记策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记策略"}},[t._v("#")]),t._v(" 标记策略")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("引用计数")]),t._v(" (reference counting)\n"),a("ul",[a("li",[t._v("垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存")]),t._v(" "),a("li",[t._v("不能解决循环引用的问题（objectA 和 objectB 通过各自的属性相互引用），可能导致内存泄漏")])])]),t._v(" "),a("li",[a("code",[t._v("标记清理")]),t._v(" (mark-and-sweep)\n"),a("ul",[a("li",[t._v("最常用的垃圾回收策略，先给当前不使用的值加上标记，再回来回收它们的内存")]),t._v(" "),a("li",[t._v("垃圾回收程序会在运行的时候，给存储在内存中的所有变量都加上标记，从根部出发将能触及到的对象的标记清除（将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉），销毁那些带标记的值（因为任何在上下文中的变量都访问不到它们了），并回收它们所占用的内存空间。")])])])]),t._v(" "),a("h3",{attrs:{id:"性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("对浏览器而言，调度垃圾回收程序方面的问题会导致性能下降")])]),t._v(" "),a("li",[a("p",[t._v("对开发者而言，理论上如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("赋值 "),a("code",[t._v("null")]),t._v("，解除对象的引用。")]),t._v(" "),a("ul",[a("li",[t._v("为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用")])])]),t._v(" "),a("li",[a("p",[t._v("静态分配（内存）策略")])])])])]),t._v(" "),a("h2",{attrs:{id:"v8垃圾回收机制♻️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制♻️"}},[t._v("#")]),t._v(" V8垃圾回收机制♻️")]),t._v(" "),a("ul",[a("li",[t._v("栈回收\n"),a("ul",[a("li",[t._v("在使用栈顶指针进行切换执行上下文的时候，栈顶内容自动被回收，这就是"),a("strong",[t._v("栈的垃圾回收机制")])])])]),t._v(" "),a("li",[t._v("堆回收\n"),a("ul",[a("li",[t._v("V8的垃圾回收策略主要基于"),a("strong",[t._v("分代式垃圾回收机制")]),t._v("，在堆中把存储空间分为"),a("strong",[t._v("新生代和老生代")]),t._v("两个部分，分别予以实施不同的回收算法")])])])]),t._v(" "),a("h3",{attrs:{id:"垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),a("p",[t._v("现代的垃圾回收算法中，按照对象的存活时间，将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qM2dmaWNpY3lPdmFzbFg2YUtoM05UeDBQcXlpYlFLVkRqandyMWVRZDBMY3ZZMTVpYkd0eTl2bXZpYU00TGpLaWFzNnlmazI1WHlibkZGSk1sVXZzNUJZRFZ3US82NDA?x-oss-process=image/format,png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"新生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[t._v("#")]),t._v(" 新生代")]),t._v(" "),a("ul",[a("li",[t._v("新生成的体积没有过大的对象、存活时间较短的对象（新生成的体积较大的对象被直接分配到大对象空间(Large Object Space) ）")]),t._v(" "),a("li",[t._v("新生代内存空间比老生代小得多")])]),t._v(" "),a("h5",[t._v("回收算法")]),t._v(" "),a("ul",[a("li",[t._v("将堆内存一分而二，其中一个处于使用状态的空间称为From空间，另一个处于闲置状态的空间称为To空间。给新对象分配内存时在from空间中进行分配，当开始进行垃圾回收时，释放 From 空间中非存活对象所占用的空间，将存活对象复制到 To 空间，完成以后To空间和From空间角色互换。所以，新生代的垃圾回收，相当于将内存空间中的存活对象，在划分的两个分区之间进行复制。")]),t._v(" "),a("li",[t._v("新生代垃圾回收的 Scavenge 算法，通过牺牲空间换时间的算法非常适合生命周期短的新生代。")])]),t._v(" "),a("h4",{attrs:{id:"老生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老生代"}},[t._v("#")]),t._v(" 老生代")]),t._v(" "),a("blockquote",[a("p",[t._v("当一个对象符合条件时，会被从新生代晋升到老生代中进行管理，这时需要采用新的算法进行垃圾回收。")]),t._v(" "),a("blockquote",[a("p",[t._v("对象晋升的条件主要有两个")]),t._v(" "),a("ol",[a("li",[t._v("一个是对象是否经历过 Scanvenge 回收（经过多次复制依然存活，则生命周期较长）")]),t._v(" "),a("li",[t._v("一个是 To 空间的内存占用超过限制（占满25%时？）")])])])]),t._v(" "),a("ul",[a("li",[t._v("存活时间较长的对象，或常驻内存的对象")]),t._v(" "),a("li",[t._v("指针空间（Old pointer space）: 存储的对象含有指向其他对象的指针")]),t._v(" "),a("li",[t._v("数据空间（Old data space）：存储的对象仅包含数据，无指向其他对象的指针")]),t._v(" "),a("li",[t._v("全局作用域中的变量不会执行垃圾回收过程，此类对象将会常驻内存（在老生代空间）。如果需要释放该类对象空间，只能通过delete，或重新赋值变量为undefind或者null来释放对象的引用。")])]),t._v(" "),a("h5",[t._v("回收算法")]),t._v(" "),a("p",[a("code",[t._v("Mark-Sweep")]),t._v(" 标记清除")]),t._v(" "),a("ul",[a("li",[t._v("标记堆内存中的所有存活对象，垃圾回收时清除那些没有被标记的对象\n"),a("ul",[a("li",[t._v("给存储在内存中的所有变量都加上标记，从根部出发，将能触及到的对象的标记清除，没有有标记的对象会被垃圾回收")])])]),t._v(" "),a("li",[t._v("但标记清除会造成一个问题，就是在清除过后会导致内存不连续，造成内存碎片。在给一个较大对象分配内存时，如果没有任何一个内存碎片有足够的空间进行分配，就会导致提前触发垃圾回收，而这次回收是不必要的。")])]),t._v(" "),a("p",[a("code",[t._v("Mark-Compact")]),t._v(" 标记整理")]),t._v(" "),a("ul",[a("li",[t._v("在标记清除的过程中，标记整理会将存活的对象和需要清除的对象移动到两端。然后将其中一段需要清除的消灭掉，可以解决标记清除造成的内存碎片问题。")]),t._v(" "),a("li",[t._v("Mark-Compact 比 Mark-Sweep 增加了一个整理的概念，它的回收执行顺序是"),a("code",[t._v("标记—整理—清除")]),t._v("。所谓的整理概念是指在标记过程中，会将存活的对象都往一端移动，完成以后再对另一端，即需要被清除的空间进行垃圾回收")]),t._v(" "),a("li",[t._v("Mark-Compact算法执行后的内存空间更合理，但是因为需要移动对象，所以它的执行速度没有Mark-Sweep快。")])]),t._v(" "),a("h3",{attrs:{id:"回收算法优化-增量标记-incremental-marking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回收算法优化-增量标记-incremental-marking"}},[t._v("#")]),t._v(" 回收算法优化——增量标记（Incremental Marking）")]),t._v(" "),a("p",[t._v("js是单线程语言，在垃圾回收的时候就会阻塞主线程的进行，尤其是在对老生代空间进行垃圾回收时，可能会导致明显的卡顿，所以v8采用增量标记的方法进行优化。本质上做的事，相当于"),a("strong",[t._v("将标记阶段分步骤进行")]),t._v("，标记一段后，就将主线程交还，用于继续执行应用逻辑，标记阶段结束之后，进入循环进行内存碎片的整理。")]),t._v(" "),a("ul",[a("li",[t._v("scavenge 算法 mark-sweep 及 mark-compact 都会导致 stop-the-world (全停顿，在执行回收时会停止应用逻辑)。而全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过 100ms，因此 V8 引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在 5ms 内，每运行一段时间标记动作， 就让 JavaScript 程序执行一会儿， 如此交替，明显地提高了程序流畅性，在一定程度上避免了长时间卡顿。")])]),t._v(" "),a("h2",{attrs:{id:"内存泄漏-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏-2"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),a("p",[t._v("由于不当的代码，有时候难免会发生内存泄漏，常见的有四个场景：")]),t._v(" "),a("ol",[a("li",[t._v("全局变量")]),t._v(" "),a("li",[t._v("闭包引用")]),t._v(" "),a("li",[t._v("事件绑定")]),t._v(" "),a("li",[t._v("缓存爆炸")])]),t._v(" "),a("h1",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("p",[t._v("《JavaScript高级程序设计》")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6854573211716321287#heading-3",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器v8引擎 > js的垃圾回收机制"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000038175558",target:"_blank",rel:"noopener noreferrer"}},[t._v("一起来看Javascript的垃圾回收机制"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904097703804936",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS垃圾回收，这次可以看懂了（带图警告）"),a("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);