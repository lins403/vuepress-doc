# 内存管理与垃圾回收

> JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收

## 内存管理

### 生命周期

1. 分配内存 
   - 声明变量、函数、对象的时候，系统会自动为它们分配内存
2. 使用内存
3. 释放内存

### 栈内存

- 原始值（String、Number、Boolean、null、undefined、Symbol），占据空间小、大小固定

### 堆内存

- 引用值（不是所有的引用类型都存储在堆中），占据空间大、大小不固定
- 闭包中的变量

### 内存泄漏

- 全局变量
- 定时器（setInterval）
- 闭包

## 栈内存和堆内存

**multithreading**

- 每个线程都有自己的栈，而堆是共享的

**store**

- 原始类型存储在栈中，引用类型存储在堆中

**size**

- 栈内存在线程创建时分配，被设置为固定大小，不能再多分配空间
- 堆内存在应用启动时分配，可以被动态分配内存大小（can grow as space is needed (the allocator requests more memory from the operating system).）

**faster**

- 栈比堆快得多，这是因为在栈上分配内存就像向上移动栈指针一样简单
- 栈上的频繁使用的数据会被处理器缓存（tends to be mapped to the processor's cache），从而更快
- 堆的分配和回收更复杂（much more complex bookkeeping），且操作还需要多线程之间的协调（coordination）
- 栈内分配和回收空间都只需要移动指针（栈指针？帧指针？）

**memory deallocated**

- 变量超出范围时，栈上的数据会被自动回收
- 堆上的数据会被一直保留，需要程序员手动删除，或者语言提供**garbage collection**帮助自动回收

**wrong**

- 栈会导致*stack overflow*，而堆会出现内存碎片化 *fragmentation*，导致没有足够的连续空间用于存储

> <http://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/>
>
> <https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap>



## 垃圾回收

#### 内存生命周期

1. 内存分配
2. 使用内存
3. 释放内存
   - JavaScript通过 <mark>自动内存管理</mark> 实现内存分配和闲置资源回收

### 回收策略

基本思路是，确定哪个变量不会再使用，然后释放它占用的内存。

这个过程是周期性的，即垃圾回收程序每隔一定时间(或者说在代码执行过程中某个预定的收集时间)就会自动运行。

#### 特殊

- 全局变量
  - 全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器；在这之前，上下文的变量对象中的变量，即全局变量，不会被当成垃圾回收
- 闭包中的变量
  - 闭包中的变量并不保存中栈内存中，而是保存在堆内存中

### 标记策略

1. `引用计数` (reference counting)
   - 垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存
   - 不能解决循环引用的问题（objectA 和 objectB 通过各自的属性相互引用），可能导致内存泄漏
2. `标记清理` (mark-and-sweep)
   - 最常用的垃圾回收策略，先给当前不使用的值加上标记，再回来回收它们的内存
   - 垃圾回收程序会在运行的时候，给存储在内存中的所有变量都加上标记，从根部出发将能触及到的对象的标记清除（将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉），销毁那些带标记的值（因为任何在上下文中的变量都访问不到它们了），并回收它们所占用的内存空间。

### 性能

1. 对浏览器而言，调度垃圾回收程序方面的问题会导致性能下降

2. 对开发者而言，理论上如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能

   - 赋值 `null`，解除对象的引用。
     - 为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用

   - 静态分配（内存）策略



## V8垃圾回收机制♻️

- 栈回收
  - 在使用栈顶指针进行切换执行上下文的时候，栈顶内容自动被回收，这就是**栈的垃圾回收机制**
- 堆回收
  - V8的垃圾回收策略主要基于**分代式垃圾回收机制**，在堆中把存储空间分为**新生代和老生代**两个部分，分别予以实施不同的回收算法

### 垃圾回收算法

现代的垃圾回收算法中，按照对象的存活时间，将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qM2dmaWNpY3lPdmFzbFg2YUtoM05UeDBQcXlpYlFLVkRqandyMWVRZDBMY3ZZMTVpYkd0eTl2bXZpYU00TGpLaWFzNnlmazI1WHlibkZGSk1sVXZzNUJZRFZ3US82NDA?x-oss-process=image/format,png)

#### 新生代

- 新生成的体积没有过大的对象、存活时间较短的对象（新生成的体积较大的对象被直接分配到大对象空间(Large Object Space) ）
- 新生代内存空间比老生代小得多

<h5>回收算法</h5>

- 将堆内存一分而二，其中一个处于使用状态的空间称为From空间，另一个处于闲置状态的空间称为To空间。给新对象分配内存时在from空间中进行分配，当开始进行垃圾回收时，释放 From 空间中非存活对象所占用的空间，将存活对象复制到 To 空间，完成以后To空间和From空间角色互换。所以，新生代的垃圾回收，相当于将内存空间中的存活对象，在划分的两个分区之间进行复制。
- 新生代垃圾回收的 Scavenge 算法，通过牺牲空间换时间的算法非常适合生命周期短的新生代。

#### 老生代

> 当一个对象符合条件时，会被从新生代晋升到老生代中进行管理，这时需要采用新的算法进行垃圾回收。
>
> > 对象晋升的条件主要有两个
> >
> > 1. 一个是对象是否经历过 Scanvenge 回收（经过多次复制依然存活，则生命周期较长）
> > 2. 一个是 To 空间的内存占用超过限制（占满25%时？）

- 存活时间较长的对象，或常驻内存的对象
- 指针空间（Old pointer space）: 存储的对象含有指向其他对象的指针
- 数据空间（Old data space）：存储的对象仅包含数据，无指向其他对象的指针
- 全局作用域中的变量不会执行垃圾回收过程，此类对象将会常驻内存（在老生代空间）。如果需要释放该类对象空间，只能通过delete，或重新赋值变量为undefind或者null来释放对象的引用。

<h5>回收算法</h5>

`Mark-Sweep` 标记清除

- 标记堆内存中的所有存活对象，垃圾回收时清除那些没有被标记的对象
  - 给存储在内存中的所有变量都加上标记，从根部出发，将能触及到的对象的标记清除，没有有标记的对象会被垃圾回收
- 但标记清除会造成一个问题，就是在清除过后会导致内存不连续，造成内存碎片。在给一个较大对象分配内存时，如果没有任何一个内存碎片有足够的空间进行分配，就会导致提前触发垃圾回收，而这次回收是不必要的。

`Mark-Compact` 标记整理

- 在标记清除的过程中，标记整理会将存活的对象和需要清除的对象移动到两端。然后将其中一段需要清除的消灭掉，可以解决标记清除造成的内存碎片问题。
- Mark-Compact 比 Mark-Sweep 增加了一个整理的概念，它的回收执行顺序是`标记—整理—清除`。所谓的整理概念是指在标记过程中，会将存活的对象都往一端移动，完成以后再对另一端，即需要被清除的空间进行垃圾回收
- Mark-Compact算法执行后的内存空间更合理，但是因为需要移动对象，所以它的执行速度没有Mark-Sweep快。

### 回收算法优化——增量标记（Incremental Marking）

js是单线程语言，在垃圾回收的时候就会阻塞主线程的进行，尤其是在对老生代空间进行垃圾回收时，可能会导致明显的卡顿，所以v8采用增量标记的方法进行优化。本质上做的事，相当于**将标记阶段分步骤进行**，标记一段后，就将主线程交还，用于继续执行应用逻辑，标记阶段结束之后，进入循环进行内存碎片的整理。

- scavenge 算法、mark-sweep 及 mark-compact 都会导致 stop-the-world (全停顿，在执行回收时会停止应用逻辑)。而全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过 100ms，因此 V8 引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在 5ms 内，每运行一段时间标记动作， 就让 JavaScript 程序执行一会儿， 如此交替，明显地提高了程序流畅性，在一定程度上避免了长时间卡顿。



## 内存泄漏

由于不当的代码，有时候难免会发生内存泄漏，常见的有四个场景：

1. 意外的全局变量
2. 被遗忘的计时器或回调函数
   - 事件绑定。在页面初始化时绑定了事件监听，但是在页面离开的时候未清除事监听
3. 脱离 DOM 的引用
   - 获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以引用也无法被回收。
   - 可以使用WeakMap结构来添加引用关系，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除
4. 闭包引用
   - 闭包会使得已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。
   - 定时器的回调通常也是个闭包，如果定时器没有被清理，其访问的变量也会被一直保留

## Recap

【内存管理/生命周期】分配内存、使用内存、释放内存

【全局变量的生命周期】全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器。在这之前，全局上下文的变量对象中的变量，也就是全局变量，不会被当成垃圾回收。

【栈内存和堆内存】栈内存在线程创建时就被分配了固定大小的空间，不能动态调整空间，所以可能引起的错误是栈溢出。堆内存在应用进程启动时分配，可以被动态分配空间大小。所以JavaScript中的基本数据类型（原始值）存储在栈内存中，它们占据空间小而且大小固定。引用类型和闭包中的变量存储在堆内存中，它们占据空间大而且大小不固定。除了动态空间大小的原因以外，如果把较大的引用类型也放入栈内存中，则会影响执行上下文的切换，从而影响程序的执行效率。栈会导致*stack overflow*，而堆会出现内存碎片化 *fragmentation*，导致没有足够的连续空间用于分配给新变量。

【垃圾回收】JavaScript通过自动内存管理实现内存分配和内存空间回收。垃圾回收的策略是确定哪个变量不会再使用，然后就可以释放它占用的内存。垃圾回收程序周期性运行，每隔一定时间就会自动运行。

【V8垃圾回收机制】栈内存回收发生在栈顶的执行上下文被推出栈的时候。V8中针对堆内存的垃圾回收策略主要基于<u>分代式垃圾回收机制</u>，在堆中按照对象的存活时间，把存储空间分为新生代和老生代两个部分，对着两个部分分别应用不同的回收算法。

【新生代】新生代的内存空间比老生代的空间小很多，存储的是新生成的对象和生命周期短的对象。如果新生成的对象体积非常大，就会被直接分配到大对象空间(Large Object Space) 。针对新生代的垃圾回收算法叫 Scavenge 算法，将堆内存一分而二，其中一个处于使用状态的空间称为From空间，另一个处于闲置状态的空间称为To空间。给新对象分配内存时在from空间中进行分配，当开始进行垃圾回收时，释放 From 空间中非存活对象所占用的空间，存活对象如果已经经历过垃圾回收，就会被复制到老生代中，否则就会被复制到 To 空间，完成以后 To 空间和 From 空间角色互换。所以，新生代的垃圾回收，相当于将内存空间中的存活对象，在划分的两个分区之间进行复制，牺牲空间换时间，适合生命周期短的对象。

【老生代】当一个对象符合条件时，会被从新生代晋升到老生代中进行管理，这时需要采用新的算法进行垃圾回收。从新生代晋升到老生代的条件主要有两个，一个是对象是否经历过新生代的垃圾回收，一个是 To 空间的内存占用超过25%的时候。老生代的垃圾回收算法采用的是`Mark-Sweep` 标记清除法和`Mark-Compact` 标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记压缩法。标记压缩法比标记清除法多了一个整理的过程，在标记过程中会将存活的对象都往一端移动，完成以后再对另一端的非存活对象进行垃圾回收。Mark-Compact算法执行后的内存空间更合理，但是因为需要移动对象，所以它的执行速度没有Mark-Sweep快。

【增量标记】js是单线程语言，在垃圾回收的时候就会阻塞主线程的进行，尤其是在对老生代空间进行垃圾回收时，标记阶段很耗时，可能会导致明显的卡顿，所以v8采用增量标记的方法进行优化。本质上做的事，相当于**将标记阶段分步骤进行**，每个步骤控制在5ms以内。标记一段后，就将主线程交还继续执行应用逻辑，如此交替以保障程序的流畅性。标记阶段结束之后，进入循环进行内存碎片的整理。



# 参考

《JavaScript高级程序设计》

 [浏览器v8引擎 > js的垃圾回收机制](https://juejin.cn/post/6854573211716321287#heading-3)

[一起来看Javascript的垃圾回收机制](https://segmentfault.com/a/1190000038175558)

[JS垃圾回收，这次可以看懂了（带图警告）](https://juejin.cn/post/6844904097703804936)

[4类 JavaScript 内存泄漏及如何避免](https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)