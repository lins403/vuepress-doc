# 排序算法

## 类型

1. 插入排序
   - 直接插入排序
   - 折半插入排序
   - 希尔排序
2. 交换排序
   - 冒泡排序
   - 快速排序
3. 选择排序
   - 简单选择排序
   - 堆排序
4. 归并排序
   - 2路归并排序
5. 基数排序

## 比较

![](https://raw.githubusercontent.com/lins403/assetsSpace/master/vuepress/img/sort_algorithm.png)

希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但目前未得出其精确的渐进时间。

### 选取排序方法需要考虑的因素

通常情况，对排序算法的比较和应用应考虑以下情况：

① 待排序的元素数目n。

② 元素本身信息量的大小。

③ 关键字的结构及其分布情况。

④ 稳定性的要求。

⑤ 语言工具的条件，存储结构及辅助空间的大小等。

### 经验方案

① 若 n 较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。

② 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。

③ 若 n 较大，则应采用时间复杂度为 O(nlog<sub>2</sub>n) 的排序方法：快速排序、堆排序或归并排序。

- 快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。
- 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。
- 若要求排序稳定且时间复杂度为O(nlog<sub>2</sub>n)，则可选用归并排序。但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。

④ 在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要 O(nlog<sub>2</sub>n) 的时间。

⑤ 若 n 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。

⑥ 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。



## 结论

### 小规模数据

直接插入排序、冒泡排序和简单选择排序是基本的排序方法，它们主要用于元素个数 n 不是很大（n<10000）的情形。

#### 时间复杂度

它们的平均时间复杂度均为O(n<sup>2</sup>)，实现也都非常简单。

`直接插入排序`对于规模很小的元素序列（n ≤ 25）非常有效。它的时间复杂度与待排序元素序列的初始排列有关。在最好情况下，直接插入排序只需要 n-1次比较操作就可以完成，且不需要交换操作。在平均情况下和最差情况下，直接插入排序的比较和交换操作都是 O(n<sup>2</sup>)。

`冒泡排序`在最好情况下只需要一趟排序过程就可以完成，此时也只需要 n-1次比较操作，不需要交换操作。

`简单选择排序`的关键字比较次数与待排序元素序列的初始排列无关，其比较次数总是 O(n<sup>2</sup>)，但元素移动次数则与待排序元素序列的初始排列有关，最好情况下数据不需要移动，最坏情况下元素移动次数不超过 3(n-1)。

#### 空间复杂度

从空间复杂度来看，这三种基本的排序方法除一个辅助元素外，都不需要其他额外空间。

#### 稳定性

从稳定性来看，直接插入排序和冒泡排序都是稳定的，但简单选择排序不是。

### 中等规模

对于中等规模的元素序列（≤1000），希尔排序是一种很好的选择。

在`希尔排序`中，开始时增量较大，分量较多，每个组内的记录数较少，因而记录的比较和移动次数较少，且移动距离较远；到后来步长越来越小（最后一步为1），分组越少，每个组内的记录数越多，但同时记录次序也越来越接近有序，因而记录的比较和移动次数也都比较少。

从理论上和实验上都已证明，在希尔排序中，记录的总比较次数和总移动次数比直接插入排序时少得多，特别是当越大时效果越明显。而且，希尔排序代码简单，基本上不需要什么额外内存，但希尔排序是一种**不稳定**的排序算法。

### 大规模

对于元素个数很大的情况，可以采用快排、堆排序、归并排序或基数排序，其中快排和堆排序都是不稳定的，而归并排序和基数排序是稳定的排序算法。

`快速排序`是最通用的高效内部排序算法，特别是它的划分思想经常在很多算法设计题中出现。平均情况下它的时间复杂度为 O(nlog<sub>2</sub>n)，一般情况下所需要的额外空间也是 O(nlog<sub>2</sub>n)。但是快速排序在有些情况下也可能会退化（如元素序列已经有序时），时间复杂度会增加到 O(n<sup>2</sup>)，空间复杂度也会增加到 O(n)。但我们可以通过“三者取中”法来避免最坏情况的发生。

`堆排序`也是一种高效的内部排序算法，它的时间复杂度是 O(nlog<sub>2</sub>n)，而且没有什么最坏情况会导致堆排序的运行明显变慢，并且堆排序基本上不需要额外的空间。但堆排序不大可能提供比快速排序更好的平均性能。

`归并排序`也是一个重要的高效排序算法，它的一个重要特性是性能与输入元素序列无关，时间复杂度总是 O(nlog<sub>2</sub>n)。归并排序的主要缺点是需要 O(n) 的额外存储空间。

`基数排序`是一种相对特殊的排序算法，这类算法不仅是对元素序列的关键字进行比较，更重要的是它们对关键字的不同位部分进行处理和比较。虽然基数排序具有线性增长的时间复杂度，但由于在常规编程环境中，基数排序的线性时间开销实际上并不比快速排序的时间开销小很多，并且由于基数排序基于的关键字抽取算法受到操作系统和排序元素的影响，其适应性远不如普通的进行比较和交换操作的排序方法。因此，在实际工作中，常规的高效排序算法如快速排序的应用要比基数排序广泛得多。基数排序需要的额外存储空间包括和待排序元素序列规模相同的存储空间及与基数数目相等的一系列桶（一般用队列实现）。

### 混合使用

我们可以混合使用不同的排序算法，这也是得到普遍应用的一种算法改进方法，例如，可以将直接插入排序集成到归并排序的算法中。

这种混合算法能够充分发挥不同算法各自的优势，从而在整体上得到更好的性能。