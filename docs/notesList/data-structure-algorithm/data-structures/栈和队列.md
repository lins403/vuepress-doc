# 栈和队列

## 栈

> 栈的内部实现原理其实就是数组或链表的操作
>
> 而之所以引入 栈 这个概念，是为了将程序设计问题模型化
>
> 用高层的模块指导特定行为（栈的先进后出特性），划分了不同关注层次，使得思考范围缩小。
>
> 更加聚焦于我们致力解决的问题核心，简化了程序设计的问题

栈顶：线性表允许进行插入删除的那一端

栈底：固定的，不允许插入删除

### 顺序存储

#### 顺序栈

- 栈顶指针：s.top，初始时设置s.top=-1；栈顶元素：s.data[s.top]。
- 入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素
- 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1
- 栈空条件：`s.top==-1`；栈满条件：`S.top==MaxSize-1`；栈长：`s.top+1`。

#### 共享栈

- 利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，仅当两个栈顶指针相邻时判断为栈满。
- 为了更有效的利用存储空间，两个栈的空间相互调节

### 链式存储

#### 链栈

- 通常采用单链表实现
- 便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况
- 便于结点的插入和删除



## 队列

队头指针front，队尾指针rear

### 顺序存储

#### 顺序队列

- 初始状态（队空条件）：Q.front == Q.rear == 0。
- 进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。
- 出队操作：队不空时，先取队头元素值，再将队头指针加1。（队尾指针没变，）会导致Q.rear==Maxsize但实际依然有空位置的“假溢出”情况

#### 循环队列

- 即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，这可以利用除法取余运算（号）来实现
- 队首指针进1： Q.front=(Q.front+1)MaxSize。队尾指针进1：Q.rear=(Q.rear+1)MaxSize。
- 区分队空和队满

### 链式存储

#### 链队列

- 实际上是一个同时带有队头指针和队尾指针的单链表。队头结点、队尾结点

#### 双端队列

- 允许两端都可以进行入队和出队操作



## 栈和队列的应用

### 栈的应用

- 括号匹配
- 表达式求值
- 递归
  - 递归的精髓在于能否将原始问题转换成相同属性但规模较小的问题
  - 递归次数过多容易造成栈溢出
  - 递归调用过程中包括很多重复的计算，效率低下。但优点是代码简单容易理解

### 队列的应用

- 层次遍历
  - 逐层或逐行处理的问题
- 操作系统
  - 缓冲区，先进先出
  - CPU资源分配，操作请求



## 特殊矩阵的压缩存储

数组：由n个相同类型的数据元素构成的有限序列

矩阵的压缩存储：指为多个值相同的元素只分配中一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。

特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。

- 常见的特殊矩阵：对称矩阵、上（下）三角矩阵、对角矩阵

特殊矩阵的压缩存储发：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。



稀疏矩阵：将非零元素构成一个三元组（行标、列标、值），然后再按某种规律存储这些三元组，可以采用数组存储或十字链表法存储
