# 补充

【输入URL到页面加载显示完成发生了什么?】首先读取地址栏的URL，然后通过域名解析，找到对应资源服务器的IP地址。通过TCP三次握手建立连接，然后就可以发送http请求了。服务器收到客户端发来的请求后，将资源返回给客户端，最后浏览器解析资源并渲染页面。

浏览器会根据服务器返回的HTML来构建DOM树，构建过程中如果遇到script标签，就会停止构建，转而去下载并执行JavaScript代码。因为浏览器不清楚js代码是否会影响到DOM，所以会同步加载和执行JS代码，从而阻塞了HTML的解析过程。为了改善这种情况，我们通常就把script标签放在body的最后。然后浏览器根据外部的CSS和自己的CSS文件，以及节点的内联样式，构建CSSOM树。构建完成DOM树和CSSOM树以后，就将它们合并为渲染树render tree，这个过程会确定每个DOM节点的计算样式。然后遍历渲染树开始layout布局，根据树中各个节点的位置和尺寸进行排列，生成布局树 layout tree。最后一步就是渲染页面，根据布局信息将像素绘制到屏幕上。

---

【数字签名和数字证书】首先数据在网络传输过程中，要担心的问题是数据被窃听、被篡改、以及数据发送人的身份被冒充。首先是使用非对称加密解决防窃听，然后是通过数字签名可以防数据被篡改，最后是引入一个第三方权威机构来防止身份被冒充，这个就是数字证书的意义。公钥和私钥的作用是，公钥是公开给大众的，用于加密数据和验证签名，而私钥是自己保留的，用于解密数据和数字签名。

【三次握手】假如说先从客户端发送请求，服务端收到以后将确认信息发送给客户端，这时候是两次握手了，客户端已经知道自己的接收和发送能力都没有问题，但是服务端还不能确认自己的发送能力是否没有问题，所以客户端需要再发送一次请求告诉它，这就是第三次握手。

【四次挥手】因为客户端请求关闭连接的时候，服务端自身还有状态，所以需要等到服务端处理完成，可以关闭的时候，再主动告诉客户端说可以关闭连接了。

---

【Cookie】cookie是一种用于维持会话状态的数据，通常是服务端将对应的状态信息，比如说是sessionId或者是token，发送给客户端，然后浏览器通过cookie保存在本地。当下一次有同源的请求时，就会将cookie携带到请求头中发送给服务端。当然cookie也可以通过js代码来设置，可以存放用户的信息比如账号密码，坐标位置等等，用于改善用户体验。但是cookie一般只能存储4k大小的数据，浏览器一般也会有数量的限制，而且cookie只能在同源页面之间使用。

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在https请求中传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。

【cookie和session认证方式】服务端验证用户的账号密码后，在session中保存用户信息，然后向浏览器返回一个sessionId，写入用户的cookie中，保存在客户端。随后用户的每次请求都会自动携带这个cookie，将sessionId发送给服务端，服务端只要根据sessionId找到对应的session，就可以取出之前保存的信息，从而维持会话状态。这种方式的缺点是不能实现跨域，而且影响扩展性，因为如果session保存在内存中，那么每次只能由同一台服务器来处理，就不适用于分布式应用中的负载均衡。

【token认证方式】服务端验证成功以后，会将登录凭证做数字签名，然后加密生成一个access token，并发送给客户端。客户端通过cookie或者是localStorage的方式将它保留在本地，以后每次请求都携带这个token。服务端验证token，验证通过时就会向客户端返回数据。当access token失效时，只需要将Refresh Token发送给服务端，而不用重新验证账号密码，就可以刷新 access token。与sessionId的认证方式有点接近，但不同点在于token不像cookie会被自动添加到请求头，token需要手动添加到header中，使用前后端协商以后的字段名称来传输。而且像JWT这样的token，可以在token中保存用户信息和加密的数据，而不需要服务端额外保存会话信息，并且还可以减少服务端对数据库的查询。

【sessionStorage 和 localStorage】sessionStorage是会话级别的存储，浏览器窗口关闭时就会被清除。而localStorage是持久化数据，会被永久保存在本地，直到通过js代码清除或者用户清理浏览器缓存。页面点击或者js的页面跳转打开的新标签页，还是同一个session，因此可以共享sessionStorage，但新建浏览器标签页或窗口打开时则不是同一个session。而localStorage没有session的限制，和cookie一样可以在所有同源标签页和窗口之间共享。

【浏览器缓存】浏览器缓存是针对http get请求的一种优化策略。当浏览器收到资源请求的响应后，在一段时间内都会保留它的副本，如果在设定的有效时间内，对这份资源再次请求，那么浏览器就会直接使用缓存的副本，而不用再发起一次完整的请求。好处是可以<u>提升页面的访问速度，并降低对网络带宽的消耗</u>。

浏览器缓存策略由服务器或代理服务器指定，分为强缓存策略和协商缓存策略。

​	使用强缓存策略时，如果缓存资源还有效，就直接使用缓存资源，不必再向浏览器发起请求。强缓存策略主要通过http headers中的 `Expires` 属性或者 `Cache-Control` 属性。后者是HTTP1.1中新引入的，精确度更高，用于替换前者，同时使用时后者的优先级也更高。先从内存加载缓存(from cache)，如果没有，则从磁盘中加载缓存(from disk)

​	如果缓存已经过期，那么就需要使用协商缓存。浏览器会向服务器发送一个请求，如果服务器确认资源没有发生修改，则返回一个304状态，让浏览器使用本地的缓存副本。如果资源发生变化，就返回修改后的资源给客户端。协商缓存的设置是通过http headers 中的 Last-Modified 属性和 Etag 属性。`Last-Modified`值表示资源上一次更改的时间，它只能精确到秒级。而 `Etag` 是资源的唯一标识符，资源变化时这个值也会变化，所以用Etag判断会更加准确，优先级更高，但是性能比前者稍差。浏览器为了让服务器判断资源是否做了修改，就将前一次请求的response header 中的 last-modified 值作为 `if-modified-since`，将 etag 值作为 `If-None-Match`，添加到request header中，发送给服务器校验。同时使用时，If-None-Match的优先级别更高。

---