# 进阶

- 组件封装
- 时间分片和虚拟滚动
- 数据驱动、响应式原理、组件化思想
- 设计模式



## 设计模式

### 观察者模式

一对多，没有中介者，只有观察者(多) 和被观察者(一) 

Vue响应式原理的实现，就是基于数据劫持实现数据变化的观察者模式，也就是我们常说的依赖收集和派发更新，当被观察的数据发生变化时，就会触发收集的观察者即watcher里的处理方法

### 发布订阅模式

发布者和订阅者不直接通信，而是通过发布订阅中心这个中介，来实现消息的发布和通知。

vue中跨组件的通信，可以使用发布订阅模式来实现。因为Vue需要使用自定义事件，所以源码内部已经实现了一个发布订阅中心，所以我们可以借鸡生蛋，直接实例化一个Vue来创建一个全局的事件中心，通过emit方法来发布消息，通过on方法来订阅消息。

通常做法是在created钩子中就去on订阅，否则可能接收不到其它组件在created时emit发出的事件；然后在beforeDestroy钩子中off移除监听。

DOM的原生事件也是发布订阅模式

### 工厂模式

JavaScript以前是用工厂函数的模式来创建一个对象，但是后来基本被new构造函数的方式取代了。

webpack的require方法是一个工厂函数，用来加载异步组件，加载以后就会把结果缓存起来以供后面使用。

JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象

### 单例模式

Vuex的store就是一个全局的单例对象；

commonjs的require方法也是一个单例模式，无论引用模块多少次，只会被加载一次；

项目中的message提示也是单例模式，只允许同时显示一条message；

可以用闭包来创建一个单例模式

### 适配器模式

vue的computed属性，或者vuex的getters属性

### 代理模式

DOM的事件委托

### 迭代器模式

提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。

forEach、for…of遍历

### 原型模式

原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。

### 职责链模式

原型链、作用域链、事件冒泡

### 装饰者模式

HOC高阶函数，这个React中用的多一些

### 享元模式

实现享元模式的核心就是学会划分内部状态(可共享) 和外部状态(不可共享)，目标是尽量减少共享对象的数量

<u>我在封装组件的时候，外层的dialog让它共享，但是具体内容呢，用动态组件来渲染</u>

### 策略模式

策略模式的目的就是将算法的使用和算法的实现分离开来。

偏函数的思想，固定部分参数并返回一个新函数，来接收其它参数。

我在写vue的自定义指令就是用到这种思想，<u>把DOM事件通过自定义指令来实现，事件的回调通过指令的表达式来传递，从而可以解耦事件的监听和事件的回调处理</u>

### 中介者模式