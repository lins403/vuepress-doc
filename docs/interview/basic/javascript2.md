# JavaScript进阶

## 面向对象

【new操作符】调用new时，首先在内存中创建一个新对象，将对象的原型指针指向构造函数的原型对象prototype，将构造函数内部的this赋值为这个新对象，然后执行构造函数内部的代码，给新对象添加属性。最后，如果构造函数没有返回对象，那么就会返回这个新创建的实例对象。

【原型对象与原型链】每个构造函数都有一个原型对象prototype，构造函数的实例对象有个属性`__proto__`，这个原型指针指向了其构造函数的prototype。prototype本身也是个对象，也有自己的原型，通过对象的原型指针串联起来的一层一层原型关系称为原型链。每个对象都会从原型prototype上继承属性和方法，当对象内也就是当前执行环境内找不到这个属性和方法时，就会从原型中去找，原型中没有时，就会继续顺着原型链往上找，直至终点Object.prototype.

【构造函数】JavaScript中对象可以利用原型链的方式，直接继承另一个对象的属性和方法，但构造函数独特的用处在于，可以接受参数进行创建/构造实例对象，给实例对象添加自己的属性。`new`操作符的意义在于，将构造函数内部的 this 指向这个被创建的新对象。实例对象的`constructor`属性指向其构造函数，构造函数的原型对象（prototype属性）有一个属性constructor指向了构造函数本身，定义在构造函数原型对象上的属性和方法，可以被所有实例共享。

【构造函数的缺陷】构造函数的缺陷在于，如果方法定义在构造函数内部，会被重复创建，而不能在实例之间共享，也不能被子类所继承。所以通常实例属性定义在构造函数中，而实例方法需要定义在原型prototype上。两面性，prototype被实例共享，所以原型对象/原型链的缺陷在于定义在原型上面的引用属性，也会被实例共享，从而导致被污染的情况。

【继承】继承是子类继承父类的属性与方法，有利用构造函数与原型链的方式，但两种方式各自有如上面所说的缺陷。比较完善的方式是组合继承和寄生组合继承，综合了构造函数与原型链的优点。二者的区别在于原型继承的方式，<u>组合继承</u>的实现是调用父类的构造函数并将结果赋值给子类的原型对象（即子类的原型对象是父类构造函数的一个实例），而<u>寄生组合继承</u>则利用`Object.create`方法，直接将父类原型对象复制给子类的原型对象（Object.create的原理是将实例对象的原型指针指向传入的参数，即使用传入的对象作为`__proto__`值）。所以**组合继承的缺陷**在于效率问题，父类构造函数始终会被调用两次，一次在是创建子类原型时调用，另一次是在子类构造函数中调用（即盗用构造函数，在子类构造函数中call调用父类构造函数，从而可以让每个实例继承的属性都是私有的）。而**寄生组合继承**被认为是实现基于类型继承的最有效方式（JavaScript没有接口继承，只有实现继承），ES6的`class`与`extends`关键字便是基于这种方式改造的。

## 执行上下文和作用域

词法分析、语法分析生成AST，检查语法错误，预编译分配内存，解释执行。

【执行上下文】执行上下文就是ECMA规范里面提到的一个抽象概念，仅仅只是一个抽象模型，具体如何实现是v8引擎内部做的事。变量或函数的上下文决定了它们的作用域和生命周期。执行上下文对后续理解 js内存、垃圾回收、闭包等具有深刻意义，它可以帮助我们在不需要很了解基础底层情况下去分析内存、跟踪执行过程。

【执行上下文的类型】任何变量都存在于某个执行上下文 (也称为`作用域`) 中，分为全局上下文、函数局部上下文，以及eval上下文。`全局上下文`在应用程序开始时创建，退出前才会被销毁。`函数上下文`在函数执行时创建，并被推到**上下文栈**顶部，函数执行结束后出栈销毁。

【变量对象VO和活动对象AO】每个执行上下文中都会有一个**包含其中变量的对象**。全局上下文中的叫`变量对象`，它会在代码执行期间始终存在。而函数局部上下文中的局部变量对象叫`活动对象`，只在函数执行期间存在，被闭包引用的活动对象除外。从ES5以后这两个概念就被词法环境和变量环境中的`环境记录`这个概念替代了。

【执行流程】ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。当 javascript 代码文件被浏览器载入后，默认最先进入的是一个`全局执行上下文`。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，即函数局部上下文，并且将其压入到执行栈顶部。浏览器总是执行位于执行栈顶部的当前执行上下文，一旦执行完毕，该执行上下文就会从执行栈顶部弹出，并且控制权返还给下方的（原来的）执行上下文。这样，执行栈中的执行上下文就会被依次执行并且弹出，直到回到全局的执行上下文。（也就是函数被调用，执行结束以后，将控制权交还给调用该函数的程序）

【作用域链】JavaScript的作用域分为全局作用域、函数作用域、以及ES6新支持的块作用域。函数在被定义时，就会为其创建作用域链，这是一个指向各级变量对象的指针列表，首先指向全局变量对象Global，并将指针列表保存在内部属性`[[Scopes]]`中。函数被调用时，创建对应的函数上下文，然后复制函数的`[[Scopes]]`属性来创建其作用域链。接着会用 arguments 和其他命名参数来初始化创建函数的`活动对象`，并将其推入**作用域链的前端**。这时候作用域链中有两个变量对象：局部变量对象（活动对象）和全局变量对象。随着函数的执行，还会往活动对象上添加变量。函数作用域就是函数上下文。

【词法作用域】词法作用域 (lexical scope) 根据源代码中声明变量的位置，来确定该变量在何处可用。普通函数的 `this` 对象会在运行时绑定到执行函数的上下文；而箭头函数比较特殊，属于词法作用域，this 会保留定义该函数时的上下文。

【块作用域】块作用域 (block scope) 是ES6新概念，在这之前只有全局作用域和函数作用域。代码块由最近的一对花括号界定，具备块作用域的变量，例如 let 和 const 声明的变量、function、class类中声明的变量等，它们的作用域不会超出这个代码块的范围。

【变量提升的原理】造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。（JS引擎解析代码阶段创建执行上下文和上下文的变量对象，代码中声明的变量也在这个时候被创建，代码运行时，在变量被声明赋值以前，就已经能访问到变量。let和const也有变量提升，只不过是存在暂时性死区，不允许在初始化前使用）

## Event Loop 事件循环

## 内存管理与垃圾回收

## Web Worker

## More

【window.performance】

【RequestAnimationFrame】

【FileReader】

【Beacon API】