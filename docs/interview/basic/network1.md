# 互联网协议



## 一、http

### 基本概念

是互联网上应用最广泛的协议，属于OSI模型应用层协议，每次会建立一个信息安全通道，来确保数据的传输。

通过http和https请求的资源，由URI（Uniform Resource Identifiers，统一资源定位符）来标识。

### 特点

- 无状态
  - 协议对信息没有缓存没有记忆
  - 所以就引入了cookie和session技术，以及浏览器缓存（304的情况是协商缓存，服务器判断是否有缓存来决定是否返回304状态码，304的话则不会返回任何资源）
- 短连接
  - 每次连接只能处理一个请求，数据请求完毕后就会断开tcp连接（只是应用层上关闭了，实际的传输层上连接并未断开，所以tcp是长连接）
  - 为了弥补这个不足，在http1.1中引入了keepalive机制，支持一个连接处理多个请求。（其实是将多个http请求合并为1个）

### HTTP 状态码

- 1XX- 信息型，服务器收到请求，需要请求者继续操作。
- 2XX- 成功型，请求成功收到，理解并处理。
- 3XX - 重定向，需要进一步的操作以完成请求。
- 4XX - 客户端错误，请求包含语法错误或无法完成请求。
  - 400状态码：请求无效，通常是接口的数据传输不对，例如content-type没有对应上；
  - 401状态码：当前请求需要用户验证；
  - 403状态码：服务器已经得到请求，但是拒绝执行
- 5XX - 服务器错误，服务器在处理请求的过程中发生了错误。
  - 500状态码：服务器内部错误
  - 501状态码：服务器不支持请求的功能
  - 502状态码：Bad Gateway，代理服务器从远程服务器收到一个无效的响应
  - 503状态码：Service Unavailable  由于超载或系统维护，服务器暂时的无法处理客户端的请求



## 二、https

### http和https

- http：超文本传输协议，信息是明文传输
- https：http下加入SSL层，由http进行通信，但利用SSL以及后来的升级版TLS进行加密数据包
- 换言之，http直接与tcp进行通信，但是加入SSL以后，就变成http先和SSL通信，后者再与tcp通信

### https的特点

#### 优点

- 可进行身份认证与加密数据传输，比http更加安全

#### 缺点

- 握手阶段比较费时
- 缓存不如http高效（*）
- 证书需要钱
- 证书需要绑定域名，域名会解析到ip上，这样就不能在一个ip下使用多个域名了

### SSL 和 TSL

SSL是由网景公司发布，后来互联网标准化组织接替SSL发布了TLS

1. 客户端向服务端索要公钥，并验证公钥，从而验证了服务端的身份（公钥存放在数字证书中，只要证书可信，公钥就可信）；

2. 然后双方协商生成"对话密钥"，之后就采用"对话密钥"进行对称加密通信（session key 是基于三个随机数生成的，通过服务器公钥来加密）

### 数字签名和数字证书

<u>公钥加密，私钥签名</u>

#### 数字签名

服务端（sender）将原数据进行 Hash 运算得到「摘要」，用自己的私钥对数据摘要进行签名，并附带和数据一起发送给客户端。客户端拿到服务端的公钥，对签名进行验签，同时也对数据进行一样的哈希算法，如果结果一致，则数据未被篡改。

#### 数字证书

数字签名的问题在于，传给客户端的签名和公钥可能被冒充，所以需要一个权威的第三方来保证公钥的安全性。

- 数字证书的颁发机构（CA），会将机构信息、有效期、公钥、持有者身份等信息，用CA的私钥进行签名，放进数字证书中。
- 服务端去CA申请一份证书，然后将证书发送给客户端。
- 客户端用CA的公钥进行验签，用服务端的公钥进行加密数据

（我理解最主要是客户端可以直接知道CA的公钥，而不用在与服务端的通信中得知，而CA的私钥必然不会泄露，所以整体是安全的）

### 常见加密方法

对称加密：**AES**、DES、3DES

非对称加密：**RSA**、ECC、DSA

散列算法：MD5、SHA1、HMAC



## 三、tcp

### 三次握手

TCP报文的Header中有标志位，用来标识每次信息的意图，包括 SYN (synchronous建立连接) 、ACK (acknowledgement 确认) 等等

客户端首先发出一个SYN消息，服务器使用SYN+ACK应答，表示接收到了这个消息，最后客户端收到服务器的SYN后，再以ACK消息响应，这样子客户端和服务端就能知道自己的发送和接受能力没有问题，所以tcp连接需要三次握手

### 四次挥手

客户端请求关闭连接时，服务端此时自身有状态，需要先自行结束，准备好关闭后再告知客户端

### tcp和udp

- tcp是面向连接的，udp是无连接的，即发送数据前不需要先建立连接
- tcp的传输是可靠的，udp是不可靠的
- tcp只能一对一，udp可以一对多

udp的应用有DNS，以及流媒体、online游戏等等



## 四、socket

socket是应用层和传输层中间的一个抽象层，把tcp/ip抽象成一组API接口，供应用层调用，以实现进程在网络中的通信（利用 **ip地址＋协议＋端口号** 来唯一标示网络中的一个进程），三次握手其实就是客户端socket和服务端socket之间基于tcp协议建立的连接。(tcp不会自动断开连接，也是需要socket编程来手动关闭)



## 五、webSocket

2008年才诞生，是一种网络传输协议，也属于OSI模型应用层协议，同时也是基于tcp协议建立的连接（webRTC是基于udp）

- 持久连接：websocket协议支持持久连接，http协议不支持持久性连接
- 全双工通信，服务端也可以主动向客户端发送信息，服务端和客户端双方可以同行给对方发送消息

（信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。）



## 六、http2.0

### HTTP1.x的缺陷

1. http是短连接，每个连接只能处理一个请求即一个资源，而且无状态使得都要反复发送一样的请求头，比较低效
2. 单向通信，只能由客户端向服务端发送请求
3. 明文传输数据内容，不安全

### HTTP2.0的特性

- 二进制格式
  - 不再是明文请求，请求信息由最小的单位二进制帧组成
- 多路复用
- header压缩和缓存
- 服务端推送





## Q&A问题

### 输入URL到页面加载显示完成发生了什么?

1. DNS域名解析，把域名解析为IP地址
2. TCP三次握手，建立连接
3. 发送HTTP请求
4. 服务器处理请求，并返回数据
5. 浏览器解析数据，并渲染页面

详尽版

1. 需要根据URL的域名解析得到<u>**服务器的IP**</u>，先查找本地缓存，依次从浏览器缓存>系统缓存>路由器缓存中查找，如果没有则查找本地的域名解析文件即hosts文件，本地查找无果，则需要去DNS服务器查找
2. 浏览器根据上一步得到的服务器IP，加上端口号，构造一个<u>**HTTP请求**</u>
3. 将http请求封装在<u>**tcp的数据包**</u>中，依次经过传输层、网络层、数据链路层、物理层，达到目标服务器
4. 服务器解析请求并做出相应，将<u>**资源**</u>返回给客户端，如果符合浏览器缓存规则，则会使用<u>**浏览器缓存**</u>的资源
5. 浏览器根据服务器返回的HTML构建<u>**DOM树**</u>，构建过程中如果遇到`script`标签，则会停止构建，转而去下载或执行<u>**JavaScript代码**</u>（毕竟浏览器并不清楚JS的执行，是否会影响到DOM，所以一般script标签放在body的最后，或者使用async、defer属性来加载JS；构建的过程中遇到图片、CSS、音视频等资源，因为不会影响到DOM的生成，所以这些资源不会阻塞HTML的解析，浏览器也会交由网络进程在后台并发下载资源）
6. 根据外部css和自己的css，以及内联样式，构建一个<u>**CSSOM树**</u>
7. 构建完成后，CSSOM树和DOM树合并为<u>**渲染树**</u> render tree （确定每个DOM节点的计算样式，排除非视觉节点，例如 `display:none` 的节点，伪元素等）
8. 之后在渲染树上进行<u>**布局layout**</u>，布局主要是遍历渲染树，确定树中各个节点的位置和尺寸（然后根据每个元素的盒模型，生成Layout tree？）
9. 之后是<u>**渲染页面**</u>，进行绘制paint和合成composite。
10. JS 解析执行



### Get请求和Post请求的区别

- 参数通过url传递，且参数有长度限制
- 只支持urlencoded一种编码类型
- 可以被浏览器主动cache
- 没有实质性的区别，都属于HTTP协议的请求方式，都是基于TCP/IP的传输层协议

https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/

```js
const httpGet = (url, callback, err = console.error) => {
  const request = new XMLHttpRequest()
  request.open('GET', url, true)
  request.onload = () => callback(request.responseText)
  request.onerror = () => err(request)
  request.send()
}
httpGet(url, console.log)
// --------------------------------------------------------------------
const httpPost = (url, data, callback, err = console.error) => {
  const request = new XMLHttpRequest()
  request.open('POST', url, true)
  request.setRequestHeader('Content-type', 'application/json; charset=utf-8')
  request.onload = () => callback(request.responseText)
  request.onerror = () => err(request)
  request.send(data)
}
httpPost(url, JSON.stringify(formData), console.log)
```

