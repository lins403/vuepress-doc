# 术语

## 一、工程化

### 基准测试

当更新同一应用程序（包括软件、硬件、网络和代码更改）时，它将再次通过性能测试，并且新的性能指标结果与以前的性能指标结果进行比较。

### 可维护性

容易理解、符合常识、容易适配、容易扩展、容易调试

1. 编程规范
2. 松散耦合
3. 编码惯例

### UX

user experience 用户体验

### 页面可插拔

TODO

## 二、功能

### 伪变量

指的是在服务端执行虚拟DOM(一般用Node.js variable

 foobar, foo, bar, baz, qux, quux, quuz, corge, grault, garply, waldo, fred, plugh, xyzzy, and thud;

### 盗链

盗链是指在自己的页面上展示一些并不在自己服务器上的内容

### REPL

read-eval-print-loop，读取 - 求值 - 打印 - 循环

浏览器控制台是个REPL运行时，与页面的 JavaScript 运行时并发。在控制台中执行的命令可以像页面级 JavaScript 一样访问全局和各种 API。控制台中可以执行任意数量的代码，与它可能会阻塞的任何页面级代码一样。修改、对象和回调都会保留在 DOM 和运行时中。

### GWT

Google Web Toolkit，是一个前端使用 JavaScript，后端使用 **Java** 的 AJAX framework

GWT透过编译器将Java代码编译成JavaScript，可让开发人员使用Java程序设计语言，快速建置与维护复杂但高性能的JavaScript前端应用程序，借此减轻开发人员负担。

### DSL

DSL（domain specific language），即领域专用语言：专门解决某一特定问题的计算机语言，比如大家耳熟能详的 SQL 和正则表达式。



## 三、编程设计模式

### 同构应用

SSR：服务端渲染，指的是服务端直接吐出具有数据的HTML页面，而不是在客户端拼接的HTML。相对的则是CSR(客户端渲染)，客户端渲染指的是在客户端通过Ajax请求来拼装数据，此时所有页面是在客户端拼接好的。

前端同构应用：一套代码，既可以客户端渲染，又可以服务端渲染。指的是在服务端执行虚拟DOM(一般用Node.js，不过其它语言也具备这项能力，之前前端程序员用JS比较多)，此时前端和服务端的渲染层是同一套代码，因为服务端使用和前端相同的虚拟DOM的原理拼接HTML模板，所以前端同构应用一般也是SSR。

同构渲染：一个前端项目里的组件，部分由服务端渲染后输出，部分由客户端异步渲染。这样可以保障网页渲染速度，也有利于搜索引擎 SEO。

[前端同构应用和 SSR 有什么区别？](https://www.zhihu.com/question/379831174/answer/1085552892)

### 控制反转模式

**控制反转**（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。

实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，

- 依赖注入（Dependency Injection，DI）是**被动**的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中。

- 依赖查找（Dependency Lookup）是**主动**索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。

IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。对于某个具体的对象而言，以前是由它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。

IoC的一个重点是，在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过依赖注入来实现的，而spring中具体注入方式是通过反射（reflection）来实现的。

> 控制反转IoC是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC 容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。

### 达夫设备 Duff’s Device

循环次数太少时，展开循环直接同步执行比循环性能更高，但又不能提前预知循环的次数时，可以使用达夫设备这一技术。

达夫设备的基本思路是以 8 的倍数作为迭代次数从而将循环展开为一系列语句，能够加快大数据集的处理速度。

```js
let iterations = Math.floor(values.length / 8); 
let leftover = values.length % 8;
let i = 0;
// 余数部分执行一个循环
if (leftover > 0) {
  do {
    process(values[i++]);
  } while (--leftover > 0);
}

// 剩余每轮循环执行8次，能够加快大数据集的处理速度
do {
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
} while (--iterations > 0);
```

### 数据对齐

- 数据对齐是指内存字节的对齐（现代计算机中内存空间都是按照byte划分），数据所在的内存地址必须是该数据长度的整数倍
- 数据对齐并不是操作系统的内存结构的一部分，而是CPU结构的一部分
- 数据对齐是为了读取数据的效率。当CPU访问正确对齐的数据时，它的运行效率最高



## 其它

投入产出比
